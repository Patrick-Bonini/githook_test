<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
  <head>
    </head>
  <body>
    <h1><a name="Publishing-Direct-Messages-Java-API"/>Publishing Direct Messages Using the Java API</h1>
    <p>Direct messages are useful when high-throughput and low-latency is required. We recommend that you publish events using direct messages if some message loss can be tolerated without negatively impacting client applications. Message loss can occur  due to external factors, such as network congestion or client disconnection.  If your applications require guaranteed delivery and message acknowledgment, then we recommend using persistent messages instead. </p>
    <p>To  handle direct messages using the <MadCap:variable name="Product-Names.pubsub_brand_only"/> Java API, use the following steps:</p>
    <ol>
      <li><a href="#Creating-A-DirectMessagePublisher-Object" class="link-internal">Create a DirectMessagePublisher Object</a>.</li>
      <li><a href="#Configuring-Messages" class="link-internal">Configure and Create an OutboundMessage</a>.</li>
      <li><a href="#Publishing-A-Direct-Message" class="link-internal">Publish a Direct Message</a>.</li>
      <li><a href="#Handling-Errors" class="link-internal">Handle Errors</a>.</li>
    </ol>
    <p>In some use cases, it's possible for your application to send messages faster than the messages can be transported. Messages can fill the API's internal buffers causing <i>back-pressure</i>. If this scenario is possible, we recommend that you consider changing the back-pressure settings to meet the requirements of your application. For more information, see  <MadCap:xref href="#Configuring-Back-Pressure">Configuring Back-pressure</MadCap:xref>.</p>
    <p>For examples of applications  that publish direct messages, see  the <a href="https://tutorials.solace.dev/java" target="_blank" class="link-offsite"><MadCap:variable name="Variables.CompanyName"/> Developer Hub</a>.</p>
    <h2 class="with-rule"><a name="Creating-A-DirectMessagePublisher-Object"/>Creating a DirectMessagePublisher Object </h2>
    <p>After a <code>MessagingService</code> object has established a connection to an event broker, use a <code>DirectMessagePublisher</code> object to publish direct messages. As with the <code>MessagingService</code> object, the <code>DirectMessagePublisher</code> object allows you to configure what features to use in the API. You can use the following methods to  set how to handle back-pressure for the  <code>DirectMessagePublisherBuilder</code> object. These methods include the <code>build()</code> method, which returns a <code>DirectMessagePublisher</code> object. You then call the <code>DirectMessagePublisher</code> method on the <code>DirectMessagePublisher</code> object to connect to the event broker.</p>
    <ul>
      <li style="font-size: 11pt;">
        <code>DirectMessagePublisherBuilder</code>
      </li>
      <ul>
        <li>
          <code>createDirectMessagePublisherBuilder()</code>
        </li>
      </ul>
      <ul>
        <li>
          <code>onBackPressureWait(int bufferCapacity)</code>
        </li>
      </ul>
      <ul>
        <li>
          <code>onBackPressureReject(int bufferCapacity)</code>
        </li>
      </ul>
      <ul>
        <li>
          <code>onBackPressureElastic()</code>
        </li>
      </ul>
      <ul>
        <li>
          <code>build()</code>
        </li>
      </ul>
      <li style="font-size: 11pt;">
        <code>DirectMessagePublisher</code>
      </li>
      <ul>
        <li>
          <code>start()</code>
        </li>
      </ul>
    </ul>
    <p>For more information, see the <a href="../../API-Developer-Online-Ref-Documentation/pubsubplus-java/index.html" class="link-internal"><MadCap:variable name="Product-Names.pubsub_brand_only"/> Messaging API for Java reference</a>.</p>
    <p>The following is an example that shows how to use  a direct message publisher to enable your application to publish messages to the event broker::</p>
    <pre xml:space="preserve">/* Creates an instance of DirectMessagePublisherBuilder */
/* that is used to create DirectMessagePublisher objects. */
final DirectMessagePublisher publisher = messagingService.createDirectMessagePublisherBuilder()
    .onBackPressureWait(1000)    // Causes the publisher thread to pause if any attempts are made to publish beyond the specified bufferCapacity (1000 in this example).
    .build()                     // Builds a DirectMessagePublisher object based on the provided configuration.
    .start();                    // Causes the service to resume regular duties. Before this method is called, the service is considered off-duty.
</pre>
    <h3>Asynchronous Receivers </h3>
    <p>It is also possible to start a direct message publisher using a callback listener to allow for asynchronous notifications after the start operation is complete.</p>
    <p>The following example shows you how to invoke <code>CompletionListener</code>, which is a callback method for listening for the results of a future computation. This handler also notifies the application when the start operation is complete. </p>
    <pre xml:space="preserve">final CompletionListener&lt;DirectMessagePublisher&gt; receiverStartupListener = (receiver, throwable) -&gt; {
    if (throwable == null) {
    // Started successfully, can receive messages.
    } else {
    // Deal with an exception during start.
    }
};
receiverToBeStarted.startAsync(receiverStartupListener);    </pre>
    <p class="Note"> Your publisher application is not operational until you call <code>start()</code> or <code>startAsync()</code> on it</p>
    <h2 class="with-rule"><a name="Configuring-Messages"/>Configuring and Creating Outbound Messages</h2>
    <p>Your client applications explicitly create the outbound messages to publish. In the <MadCap:variable name="Product-Names.pubsub_brand_only"/> Java API, when you publish messages you use <code>OutboundMessage</code> objects. To configure and create <code>OutboundMessage</code> objects, follow these steps: </p>
    <ol>
      <li>
        <p>Call  <code>messagingService.messageBuilder()</code> to return an <code>OutboundMessageBuilder</code> object. For better performance, we recommend you use a single <code>OutboundMessageBuilder</code> to create multiple <code>OutboundMessage</code> objects. </p>
        <pre xml:space="preserve">final OutboundMessageBuilder messageBuilder = messagingService.messageBuilder()</pre>
      </li>
      <li>Configure your message with an <code>OutboundMessageBuilder</code> and then call the <code>build()</code> method to return a message object. You can configure message properties using either method below.
			
				<ul><li>Use the <code>Properties</code> interface and the <code>setProperty(name,value)</code> method. The following example shows how to set a custom name-value property on a <code>Properties</code> object, and then configure a message using the <code>fromProperties()</code> method:		<pre xml:space="preserve">
final Properties messageProperties = new Properties();
messageProperties.setProperty("PropertyName", "PropertyValue");
final OutboundMessage message = messageBuilder
    .fromProperties(messageProperties)
    .build(messagePayload);	</pre></li><li>Use the <code>OutboundMessageBuilder</code> interface and the <code>with*()</code> methods. The following example shows how to set  Sender ID, and a custom key-value property on a message:<pre xml:space="preserve">
final OutboundMessage myCustomMessage = messageBuilder
    .withSenderId("mySenderId")   
    // For a complete list of with*() methods see the <a href="../../API-Developer-Online-Ref-Documentation/pubsubplus-java/index.html" class="link-internal"><a href="../../API-Developer-Online-Ref-Documentation/pubsubplus-java/index.html" class="link-internal"><MadCap:variable name="Product-Names.pubsub_brand_only"/> Messaging API for Java reference</a></a>
    .withProperty("PropertyKey", "PropertyValue") 
    .build(messagePayload);</pre></li></ul></li>
    </ol>
    <p>The following code example shows how to create a message builder, set message properties and create a message:</p>
    <pre xml:space="preserve">
/* Builder for creation of similarly configured messages */
final OutboundMessageBuilder messageBuilder = messagingService.messageBuilder();
final OutboundMessage message = messageBuilder
    .fromProperties(messageProperties)       // For example TTL, Sender ID, Sequence Number etc.  
    .withExpiration(Instant.now()            // Sets expiration time using the current system time as starting point.
    .toEpochMilli() + 10000L)                // Expire the message in 10 seconds.
    .build("My_Message");                    // Builds the message.</pre>
    <p>For more information about the methods, see the <a href="../../API-Developer-Online-Ref-Documentation/pubsubplus-java/index.html" class="link-internal"><a href="../../API-Developer-Online-Ref-Documentation/pubsubplus-java/index.html" class="link-internal"><MadCap:variable name="Product-Names.pubsub_brand_only"/> Messaging API for Java reference</a></a>.</p>
    <h2 class="with-rule"><a name="Configuring-Back-Pressure"/>Handling Back-Pressure When Publishing Direct Messages</h2>
    <MadCap:snippetBlock src="../../Resources/Snippets/API-Guide/NG-API/backpressureintro-publisher-direct-messages.flsnp"/>
    <p>In our Java API, the <code>DirectMessagePublisher</code> has the following  mechanisms to handle back-pressure:</p>
    <ul>
      <li>
        <a href="#reject" class="link-internal">reject messages when a specified limit is reached</a>
      </li>
      <li>
        <a href="#throttle" class="link-internal">throttle the application  when a specified limit is reached</a>
      </li>
      <li>
        <a href="#no-limit" class="link-internal">use an unlimited internal publishing buffer (default)</a>
      </li>
    </ul>
    <h3><a name="reject"/>Rejecting Messages When A Specified Limit is Reached </h3>
    <p>When back-pressure occurs, you can choose to reject the messages from the client application when a specified limit is reached in the internal buffer. You can use the <code>onBackPressureReject(int bufferCapacity)</code> method to specify a defined buffer capacity for a set number of messages to accumulate. After the specified capacity is reached, it is no longer possible to publish new messages and the API throws exceptions until the buffer has capacity again. On calls to publish, the value for <code>bufferCapacity</code> must be greater than zero. </p>
    <pre xml:space="preserve">/* Creates an instance of DirectMessagePublisherBuilder, which is used to create DirectMessagePublisher objects. */
final DirectMessagePublisher publisher = messagingService.createDirectMessagePublisherBuilder()
    .onBackPressureReject(1000)    // Creates a message buffer with space to accommodate 1000 messages, at which point messages are rejected until there is room.
    .build()                       // Builds a DirectMessagePublisher object based on the provided configuration.    
    .start();                      // Causes the service to start regular duties. Before this method is called, the service is considered off-duty.</pre>
    <h4>Using a Publisher Readiness Listener</h4>
    <p>We recommend that you use a <code>PublisherReadinessListener</code> interface when you use the <code>onBackPressureReject()</code> method because it lets your application known when there is capacity available in the buffer and it can resume publishing messages. </p>
    <p>The following is an example of  registering an event handler<code>PublisherReadinessListener</code> interface : </p>
    <pre xml:space="preserve">/* Creates an instance of DirectMessagePublisherBuilder, which is used to create DirectMessagePublisher objects. */
final DirectMessagePublisher publisher = messagingService.createDirectMessagePublisherBuilder()
    .onBackPressureReject(1000)    // Creates a message buffer with space to accommodate 1000 messages, at which point messages are rejected until there is room.
    .build()                       // Builds a DirectMessagePublisher object based on the provided configuration.    
    .start();                      // Causes the service to resume regular duties. Before this method is called, the service is considered off-duty.

final PublisherReadinessListener canPublishListener = () -&gt; {
<b>// This code is executed when our publisher is ready to publish again.</b> 
};
publisher.setPublisherReadinessListener(canPublishListener);    // Register listener, usually set once.        
</pre>
    <h3><a name="throttle"/>Throttling the Publisher When a Specified Limit is Reached</h3>
    <p>You can choose to throttle the publishing application if a specified limit is reached in the internal buffer. The use of throttling is useful to free capacity to its internal buffers. You can use the <code>onBackPressureWait()</code> method to set the maximum number of messages that can accumulate in the buffer. When this maximum capacity (<code>bufferCapacity</code>) is reached, the publisher thread pauses and waits for  available capacity in the internal buffer before letting the application publish any more messages.</p>
    <p> This method should be used when you want the application's publishing requests to wait for space when the buffer's capacity has been reached. Using this mechanism effectively gives time for the API to empty the internal buffer. An additional benefit is that when you use persistent publishing, the API does not discard any messages. </p>
    <p>The following shows an example of how to configure the internal buffer to accommodate up to one thousand messages:</p>
    <pre xml:space="preserve">/* Creates an instance of DirectMessagePublisherBuilder, which is used to create DirectMessagePublisher objects. */
final DirectMessagePublisher publisher = messagingService.createDirectMessagePublisherBuilder()
    .onBackPressureWait(1000)    // Creates a message buffer with space to accommodate 1000 messages, at which point the thread pauses until there is room.
    .build()                     // Builds a DirectMessagePublisher object based on the provided configuration.    
    .start();                    // Causes the service to resume regular duties. Before this method is called, the service is considered off-duty.</pre>
    <h3><a name="no-limit"/>Configuring an Unlimited Internal Buffer </h3>
    <MadCap:snippetBlock src="../../Resources/Snippets/API-Guide/NG-API/publish-unlimited-buffer.flsnp"/>
    <p>When you use an unlimited buffer, the Java API continuously  puts messages on the internal buffer it published by the client application. The following example shows an explicit call to the  <code>onBackPressureElastic()</code> method, which is not required because it is the default behavior:</p>
    <pre xml:space="preserve">/* Creates an instance of DirectMessagePublisherBuilder, which is used to create DirectMessagePublisher objects. */
final DirectMessagePublisher publisher = messagingService.createDirectMessagePublisherBuilder()
    .onBackPressureElastic()    // Creates an unlimited capacity message buffer. 
    .build()                    // Builds DirectMessagePublisher object based on the provided configuration.    
    .start();                   // Causes the service to resume regular duties. Before this method is called, the service is considered off-duty.
</pre>
    <h2 class="with-rule"><a name="Publishing-A-Direct-Message"/>Publishing a Direct Message</h2>
    <p>After you have created the <code>DirectPublisher</code> object, you can start sending messages. When you send a message, there are two primary components:</p>
    <ul>
      <li>the topic to publish on  <a href="https://docs.solace.com/Get-Started/Understanding-Topics.htm" class="link-internal">(Understanding Topics)</a></li>
      <li>the payload of the message (optional) </li>
    </ul>
    <p>The topic must be an object of the <code>Topic</code> class that follows the <MadCap:variable name="Variables.CompanyName"/> hierarchical format, for example: <code>solace/messaging/direct/pub</code>. The publish method currently supports simple string messages, byte arrays, as well as objects of the <code>OutboundMessage</code> class, which can be obtained through an <code>OutboundMessageBuilder</code> via <code>MessagingService.messageBuilder()</code>. The following are methods to publish a direct message:</p>
    <ul>
      <li>
        <code>publish(byte[] message, Topic destination)</code>
      </li>
      <li>
        <code>publish(OutboundMessage message, Topic destination)</code>
      </li>
      <li>
        <code>publish(OutboundMessage message, Topic destination, Properties additionalMessageProperties)</code>
      </li>
      <li>
        <code>publish(String message, Topic destination)</code>
      </li>
    </ul>
    <p> See the <a href="../../API-Developer-Online-Ref-Documentation/pubsubplus-java/index.html" class="link-internal"><MadCap:variable name="Product-Names.pubsub_brand_only"/> Messaging API for Java reference</a> for information about the publish methods that are available in the <code>DirectMessagePublisher</code> interface</p>
    <p>Here's an example that shows how to publish a direct message:</p>
    <pre xml:space="preserve">while (System.in.available() == 0 &amp;&amp; !isShutdown) {
    try {          
    String message = "This is a message from Solace";    // The contents or payload of the message. 
    String topicString = "solace/samples/direct/pub";    // The topic the message is published to on the event broker.
    publisher.publish(message,Topic.of(topicString));    // This method publishes the message to the topic until stopped by conditions in while loop.
    } catch (RuntimeException e) { 
        System.out.printf("### Caught while trying to publisher.publish(): %s%n",e);
        isShutdown = true;  
    } finally {
        try {
        Thread.sleep(1000 / APPROX_MSG_RATE_PER_SEC);   
        } catch (InterruptedException e) {
        isShutdown = true;
            }
        }
    }</pre>
    <h2 class="with-rule"><a name="Handling-Errors"/>Handling Errors</h2>
    <p>The <MadCap:variable name="Product-Names.pubsub_brand_only"/> Java API provides the <code>setPublishFailureListener()</code> method that notifies the client if the API is unable to publish messages. A failed publish event could be due to an issue such as an invalid topic or a termination of the service.  See the example below:</p>
    <pre xml:space="preserve">/* Creates an instance of DirectMessagePublisherBuilder, which is used to create DirectMessagePublisher objects. */
final DirectMessagePublisher publisher = messagingService.createDirectMessagePublisherBuilder()
    .onBackPressureWait(1000)    // Creates an unlimited capacity message buffer. 
    .build()                     // Builds a DirectMessagePublisher object based on the provided configuration.    
    .start();                    // Causes the service to resume regular duties. Before this method is called, the service is considered off-duty.

publisher.setPublishFailureListener(e -&gt; {   // Can be called for access control list violations. 
System.out.println("### FAILED PUBLISH " + e);  // In this example, an error message is printed.
});        </pre>
  </body>
</html>
