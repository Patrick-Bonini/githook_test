<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
  <head>
    <link href="../../../Resources/TableStyles/Table_Num.css" rel="stylesheet" MadCap:stylesheetType="table"/>
  </head>
  <body>
    <h1>Using <MadCap:variable name="Product-Names.pubsub_cache"/> With the .NET API</h1>
    <p>This section describes how to develop applications using the messaging application programming interface (API) for .Net, also known as SolClient for .NET, to perform cache requests over an event broker network.</p>
    <p>The basic steps to make a cache request in a session are:</p>
    <ol>
      <li>Create a cache session. Refer to <MadCap:xref href="#Creating">Creating Cache Sessions</MadCap:xref>.</li>
      <li>Send a cache request message. Refer to <MadCap:xref href="#Sending">Sending Cache Requests</MadCap:xref>.</li>
      <li>Receive requested cached messages. Refer to <MadCap:xref href="#Receivin">Receiving Cached Messages</MadCap:xref>.</li>
      <li>Destroy the cache session object when done with cache requests. Refer to <MadCap:xref href="#Destroyi">Destroying Cache Sessions</MadCap:xref>.</li>
    </ol>
    <h2 class="with-rule"><a name="Creating"/>Creating Cache Sessions</h2>
    <p>Once <code>JCSMPSession</code> is acquired, a client can call the <code>createCacheSession(CacheSessionProperties)</code> method and pass in the cache session properties listed in the <MadCap:xref href="#Cache">Cache Session Property Parameters</MadCap:xref> table to create a cache session object.</p>
    <p>A cache session object allows multiple outstanding cache requests and synchronizes those requests. A single session can have many cache session objects.</p>
    <pre class="Code">CacheSessionProperties cacheProps = new CacheSessionProperties();
cacheProps.CacheName = cacheName;
cacheProps.MaxMessagesPerTopic = maxMsgs;cacheProps.MaxMessageAgeInSecs = maxAge;
cacheProps.CacheRequestTimeoutInMsecs = timeout;
ICacheSession cacheSession</pre>
    <p>Then, using a session instance reference, invoke the <code>CreateCacheSession()</code> method and pass in the cache session properties, as follows:</p>
    <pre class="Code">session.CreateCacheSession(cacheProps);</pre>
    <table class="TableStyle-Table_Num" style="caption-side: top;mc-table-style: url('../../../Resources/TableStyles/Table_Num.css');width: 95%;" cellspacing="0">
      <caption valign="top" style="padding-bottom: 3pt;">
        <p class="TblCaption"><a name="Cache"/>Cache Session Property Parameters</p>
      </caption>
      <col width="25%" class="TableStyle-Table_Num-Column-Column1"/>
      <col class="TableStyle-Table_Num-Column-Column1" style="width: 75%;"/>
      <thead>
        <tr class="TableStyle-Table_Num-Head-Header1">
          <th class="TableStyle-Table_Num-HeadE-Column1-Header1">Parameter</th>
          <th class="TableStyle-Table_Num-HeadD-Column1-Header1">Description</th>
        </tr>
      </thead>
      <tbody>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p class="Tbl_BodyCode">CacheName</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p class="Tbl_Body">The identifying name of the Distributed Cache, Cache Cluster, or PubSub+ Cache Instance to send the cache requests to.</p>
            <p class="Note">Specifying a PubSub+ Cache Instance bypasses redundancy and load balancing of cache requests. Specifying the Distributed Cache is the preferred method.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p class="Tbl_BodyCode">CacheRequestTimeoutInMsecs</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p class="Tbl_Body">The amount of time (in milliseconds) to wait for a response to the cache request from the cache. This is a per-request timeout where each request sent by the application could result in multiple underlying requests.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p class="Tbl_BodyCode">MaxMessageAgeInSecs</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p class="Tbl_Body">The maximum age (in seconds) of the messages to retrieve. Messages that have been cached for more than this amount of time are not retrieved.</p>
            <p class="Note">A value of 0 returns all possible messages for the topic, as defined by <code>MaxMessagesPerTopic</code>.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyB-Column1-Body1">
            <p class="Tbl_BodyCode">MaxMessagesPerTopic</p>
          </td>
          <td class="TableStyle-Table_Num-BodyA-Column1-Body1">
            <p class="Tbl_Body">The maximum number of cached messages to retrieve for any one topic. If more messages are cached for a topic than the maximum value, the newest messages are returned.</p>
            <p class="Note">A value of 0 retrieves all messages newer than <code>MaxMessagesPerTopic</code>.</p>
          </td>
        </tr>
      </tbody>
    </table>
    <h2 class="with-rule"><a name="Sending"/>Sending Cache Requests</h2>
    <p>An application can send a cache request message by invoking one of the following methods on <code>ICacheSession</code>:</p>
    <ul>
      <li><code>ReturnCode SendCacheRequest(Int64 requestId, ITopic topic, bool subscribe, CacheLiveDataAction liveDataAction)
</code><![CDATA[                ]]><p>A synchronous cache request. When this method is invoked, the API waits for the cache response to be fulfilled according to the <code>CacheLiveDataAction</code> handling options.</p></li>
    </ul>
    <ul>
      <li>
        <code>ReturnCode SendCacheRequest(Int64 requestId, ITopic topic, bool subscribe, CacheLiveDataAction liveDataAction, EventHandler&lt;CacheRequestEventArgs&gt; cacheRequestListener)
</code>
        <p>An asynchronous cache request. When this method is invoked, the API returns immediately upon successful buffering of the cache request for transmission. The result of the request is reported through the<code> cacheRequestListener</code>.</p>
      </li>
    </ul>
    <p>When the client application sends a cache request message, it must provide the parameters listed below.</p>
    <table class="TableStyle-Table_Num" style="caption-side: top;mc-table-style: url('../../../Resources/TableStyles/Table_Num.css');width: 95%;" cellspacing="0">
      <caption valign="top" style="padding-bottom: 3pt;">
        <p class="TblCaption">Cache Request Message Parameters</p>
      </caption>
      <col style="width: 25%;" class="TableStyle-Table_Num-Column-Column1"/>
      <col style="width: 75%;" class="TableStyle-Table_Num-Column-Column1"/>
      <thead>
        <tr class="TableStyle-Table_Num-Head-Header1">
          <th class="TableStyle-Table_Num-HeadE-Column1-Header1">Parameter</th>
          <th class="TableStyle-Table_Num-HeadD-Column1-Header1">Description</th>
        </tr>
      </thead>
      <tbody>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p class="Tbl_BodyCode">requestId</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p class="Tbl_Body">A positive Int64 that is returned to the application in the cache request response. The request ID is available in every cached message returned.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p class="Tbl_BodyCode">topic</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p class="Tbl_Body">An <code>ITopic</code> instance that represents the topic requested from the cache. Use of <code>#noexport</code> is not supported in the topic.</p>
            <p class="Note">Wildcard cache requests are only supported for FLOW_THRU cache requests. When a wildcard request matches multiple cached subjects, there are no temporal ordering guarantees between the individual topics returned (although temporal ordering will still be preserved amongst the messages for a specific topic).</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p class="Tbl_BodyCode">liveDataAction</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p class="Tbl_Body">Enumerated actions to perform on receiving a live data message during an outstanding cache request. The possible actions include:</p>
            <ul>
              <li><code>FULFILL</code>—Deliver live data matching the cache request to the application immediately. The subsequent cache response is discarded.</li>
              <li><code>QUEUE</code>—Queue live data matching the cache request topic until the cache-response is received, and deliver the matching live data to the application after the cache response data. Live data not matching an outstanding cache request is immediately delivered to the application.</li>
              <li><code>FLOW_THRU</code>—Deliver live data matching the cache request to the application immediately. The subsequent cache response is also delivered. Wildcard cache requests must be <code>FLOW_THRU</code>.</li>
            </ul>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyE-Column1-Body1">
            <p class="Tbl_BodyCode">subscribe</p>
          </td>
          <td class="TableStyle-Table_Num-BodyD-Column1-Body1">
            <p class="Tbl_Body">If this parameter is set to <code>true</code>, send a subscription request to the event broker for the topic with the cache request.</p>
            <p class="Tbl_Body">By sending a subscription with the cache request, the client will receive relevant live data messages after it has received all of the cached messages.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyB-Column1-Body1">
            <p class="Tbl_BodyCode">cacheRequestListener</p>
          </td>
          <td class="TableStyle-Table_Num-BodyA-Column1-Body1">
            <p class="Tbl_Body">The delegate for reporting cache request completion status. This parameter is only used for asynchronous cache requests.</p>
          </td>
        </tr>
      </tbody>
    </table>
    <h2 class="with-rule"><a name="Receivin"/>Receiving Cached Messages</h2>
    <p>Cached messages are received through the <code>EventHandler&lt;MessageEventArgs&gt;</code> delegate.</p>
    <p>The API does not attempt to reorder cached messages that are received across different Cache Clusters. In addition, the API does not attempt to drop duplicate messages received from Cache Clusters or live publishers.</p>
    <p class="Note">Messages in cache responses may be bundled together by the cache, but they are delivered to applications individually by the messaging API.</p>
    <p>If an application registers an event callback delegate with a non-blocking cache request, the cache request status is returned in the return code of the <code>CacheRequest EventArg</code>.</p>
    <div class="Note">
      <p>The .NET API supports topic dispatch on cache requests. However, if topic dispatch is enabled for a session, messages returned as part of a cache request are only delivered to the session receive callback if the session has a matching subscription.</p>
    </div>
    <p>The following table lists the return codes that can be returned. Although these codes are also returned for non-cache request API calls for clients connecting to an event broker, the provided descriptions indicate what the events signify for a cache request.</p>
    <table class="TableStyle-Table_Num" style="caption-side: top;mc-table-style: url('../../../Resources/TableStyles/Table_Num.css');width: 95%;" cellspacing="0">
      <caption valign="top" style="padding-bottom: 3pt;">
        <p class="TblCaption">Cache Request Events</p>
      </caption>
      <col style="width: 25%;" class="TableStyle-Table_Num-Column-Column1"/>
      <col style="width: 75%;" class="TableStyle-Table_Num-Column-Column1"/>
      <thead>
        <tr class="TableStyle-Table_Num-Head-Header1">
          <th class="TableStyle-Table_Num-HeadE-Column1-Header1">Event</th>
          <th class="TableStyle-Table_Num-HeadD-Column1-Header1">Description</th>
        </tr>
      </thead>
      <tbody>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p class="Tbl_BodyCode">SOLCLIENT_OK</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p class="Tbl_Body">Indicates that:</p>
            <ul>
              <li>the cache replies were all received before the timer expired</li>
              <li>none of the received cached messages were suspect</li>
              <li>at least one cache reply had data</li>
            </ul>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p class="Tbl_BodyCode">SOLCLIENT_INCOMPLETE</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p class="Tbl_Body">Indicates that incomplete data has been returned. Reasons might include:</p>
            <ul>
              <li>all of the cache replies contained no data</li>
              <li>at least one message was suspect</li>
            </ul>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyB-Column1-Body1">
            <p class="Tbl_BodyCode">SOLCLIENT_FAIL</p>
          </td>
          <td class="TableStyle-Table_Num-BodyA-Column1-Body1">
            <p class="Tbl_Body">Indicates that an error occurred during the initial cache request. Possible reasons include:</p>
            <ul>
              <li>timeout waiting for a cache response</li>
              <li>a cache error response</li>
              <li>an add subscription error response</li>
              <li>a transport error when communicating with the event broker</li>
            </ul>
            <div class="Note">
              <ul>
                <li>If an error occurs after the initial cache request (for example, when communicating with further cache instances in the Cache Cluster), then <code>SOLCLIENT_INCOMPLETE</code> is returned.</li>
                <li>If a failure occurs, the API does not automatically retry any outstanding cache requests. In addition, if there is a loss of connection with the event broker, any outstanding cache requests are canceled.</li>
              </ul>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
    <h2 class="with-rule"><a name="Destroyi"/>Destroying Cache Sessions</h2>
    <p>To cancel all outstanding requests and destroy the cache session, call the<code> ICacheSession.Dispose() </code>method. It is safe to call this method from any thread.</p>
    <p>When <code>Dispose()</code> is called, the following occurs:</p>
    <ul>
      <li>all outstanding cache requests are cancelled</li>
      <li>live messages that have been queued are delivered</li>
      <li>all blocked synchronous cache requests return immediately with an <code>SOLCLIENT_INCOMPLETE</code> return code, a <code>ParamNullReference</code> subcode, and a “Cache session has been destroyed” error string</li>
      <li>no event is generated for in-progress asynchronous cache requests</li>
    </ul>
    <h3><a name="Cancelin"/>Canceling Cache Requests</h3>
    <p>To cancel all outstanding requests, without destroying the cache session, call the <code>ICacheSession.CacheRequestCancelled() </code>method. It is safe to call this method from any thread, and it can be called repeatedly.</p>
    <p>When <code>CacheRequestCancelled()</code> is called, the following occurs:</p>
    <ul>
      <li>all outstanding cache requests are canceled</li>
      <li>all live messages that have been queued are delivered</li>
      <li>all blocked synchronous cache requests return immediately with a <code>SOLCLIENT_INCOMPLETE</code> return code and a <code>CacheRequestCancelled</code> subcode</li>
      <li>a cache event <code>RequestCompletedNotice</code> with a subcode of <code>CacheRequestCancelled</code> is generated for each in‑progress asynchronous cache request</li>
    </ul>
  </body>
</html>
