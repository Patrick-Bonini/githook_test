<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
  <head>
    <link href="../../Resources/TableStyles/Table_Num.css" rel="stylesheet" MadCap:stylesheetType="table"/>
    <meta name="keywords" content="rmem_max, wmem_max, tcp_wmem, Java API, best practices"/>
  </head>
  <body>
    <h1>JCSMP Best Practices</h1>
    <h2 class="with-rule"><a name="General"/>General Best Practices</h2>
    <h3><a name="Tuning"/>Tuning Guidelines for Guaranteed Messaging</h3>
    <MadCap:snippetBlock src="Snippets/Tune-Guide-Guarn-Msg.flsnp"/>
    <h3><a name="Reapply"/>Reapply Subscriptions</h3>
    <MadCap:snippetBlock src="Snippets/Reapply-Sub.flsnp"/>
    <p>For more information, see <MadCap:xref href="#Subscrip">Subscription Management</MadCap:xref>.</p>
    <h3><a name="Number2"/>Number of Flows and Guaranteed Message Window Size</h3>
    <MadCap:snippetBlock src="Snippets/Flow-Guarn-Msg-Win-Size.flsnp"/>
    <div class="Note">
      <p>If you are using JCSMP, you also need to tune the size of the Java consumer notification dispatcher queue so that it is large enough to buffer the maximum number of notifications that can be generated by all consumer flows (Guaranteed message flows as well as direct consumers) contained in all Sessions in a Context.
			<p style="text-align: left;"><img style="margin-left: 5.99976px;margin-top: 5.99976px;margin-right: 5.999783px;margin-bottom: 5.999763px;" src="Images/queue_size_equation.png" alt="Illustration depicting the concepts described in the surrounding text."/></p><p><u>Where</u>:</p><p><code>GDFlows</code> is all of the Guaranteed message consumer Flows in a Context.</p><p><code>FCL</code> is the default consumer Flow congestion limit.</p><p><code>Nconsumers</code> is the number of Direct message consumers in a Context.</p></p>
    </div>
    <h3><a name="Minimum"/>Minimum Message Burst Size</h3>
    <MadCap:snippetBlock src="Snippets/Min-Msg-Burst-Size.flsnp"/>
    <h2 class="with-rule"><a name="Basic"/>Basic Rules</h2>
    <p>When programming using JCSMP, it's useful to remember the following basic rules: </p>
    <ul>
      <li>durable and non-temporary objects (such as durable endpoints) are created at the Factory level</li>
      <li>non‑durable and temporary objects are created at the Session level</li>
      <li>flows are created at the Session level</li>
    </ul>
    <h2 class="with-rule"><a name="Threadin"/>Threading</h2>
    <h3><a name="API"/>API Threading</h3>
    <h4>Recommendation</h4>
    <ul>
      <li>Consider dispatching messages directly from the I/O thread if optimizing latency is most important. This model is the default behavior for C, .NET, and Java RTO APIs.</li>
    </ul>
    <p>The APIs use a Context to organize communication between a client application and a Solace PubSub+ event broker.  A Context is a container for one or more Sessions.  The Context is responsible for handling Session related events and encapsulates threads that drive network I/O and message delivery notification for the Sessions.</p>
    <p>Solace’s JCSMP is implemented to be inherently blocking, that is, calls available to the application could block.  To address this, the API runs a separate dispatcher thread so that the application can make blocking calls within callbacks while still allowing the network I/O thread to continue reading the messages off the network.  As the messages continue to be accepted into the API, a storing mechanism called the Notification Queue is used to keep track of the messages before they are dispatched to the client application by the dispatcher thread.</p>
    <p>Unlike JCSMP, the C, .Net and Java RTO APIs are implemented to be inherently non-blocking. And, as such, client applications are not allowed to make blocking calls within callbacks using these APIs. Hence these implementations do not require separate dispatch and I/O threads. A Context thus has a single processing thread which is used to read messages off the socket as well as perform notification and message dispatching.</p>
    <p>Dispatching directly from the I/O thread has the benefit of optimizing latency as messages are not being queued up in the Notification Queue which can potentially inject latency.  Therefore C, .NET, and Java RTO APIs should be considered for latency sensitive applications.  JCSMP can also be configured to dispatch directly from its I/O thread (called the “reactor” thread).  To do so, enable the MESSAGE_CALLBACK_ON_REACTOR in the session property.  In this case, however, the application must then ensure that it does not block in the callbacks.  Otherwise, a deadlock may occur if the API is waiting for a response from the event broker but the thread is blocked for reading that response.</p>
    <p>Although dispatching directly from the I/O thread reduces message latency, it also decreases the potential maximum message throughput as the messages are processed individually instead of in batches.  This aspect should also be weighed in when deciding on the API threading model to implement. As the typical message size of an application plays a major determining factor in this regard, a performance evaluation prior to model selection is recommended when necessary.</p>
    <p>For further details on threading interactions, please refer to <MadCap:xref href="API-Threading.htm">API Threading
		</MadCap:xref>.</p>
    <h3><a name="Context"/>Context and Session Threading Model Considerations</h3>
    <MadCap:snippetBlock src="Snippets/Context-Session-Thread-Model-Consider.flsnp"/>
    <h2 class="with-rule"><a name="Always"/>Always Cleanup</h2>
    <p><code>JCSMPSession</code>, <code>XMLMessageProducer</code>, and <code>XMLMessageConsumer</code> are all related to system resource allocation. Close them properly whenever they are no longer used anymore or if an error occurs.</p>
    <p class="Note">Closing <code>JCSMPSession</code> closes any <code>Producer</code> and <code>Consumer</code> associated with it.</p>
    <h2 class="with-rule"><a name="Increase"/>Increase Buffer Sizes When Publishing Large Messages</h2>
    <p>On some Java Virtual Machines (JVMs), some users have reported it necessary to increase the socket send and receive buffer sizes when publishing large messages. The default socket buffer size used by Java is 64 KB.</p>
    <p>To modify the send socket buffer size, call <code>JCSMPChannelProperties#setSendBuffer(int so_sendbuf)</code>. To modify the receive socket buffer size, call <code>JCSMPChannelProperties#setReceiveBuffer(int so_rcvbuf)</code>.</p>
    <p>If your application is running on a Linux system, you must also change its TCP buffer size settings. Add variables rmem_max, wmem_max, tcp_rmem, and tcp_wmem as shown in the following snippet to <code>/etc/sysctl.conf</code> file.</p>
    <pre class="Code" xml:space="preserve"># increase TCP maximum buffer size
net.core.<span class="sample_snippet">rmem_max</span> = 16777216
net.core.<span class="sample_snippet">wmem_max</span> = 16777216
 
# increase Linux autotuning TCP buffer limits
# min, default, and maximum number of bytes to use
net.ipv4.<span class="sample_snippet">tcp_rmem</span> = 4096 87380 16777216 
net.ipv4.<span class="sample_snippet">tcp_wmem</span> = 4096 65536 16777216</pre>
    <p>Scale the buffer sizes appropriately to handle the maximum message size and the network links to be encountered, then run <code>sysctl -p</code>. The values are set when the system is booted.</p>
    <h2 class="with-rule"><a name="TCP"/>TCP Send and Receive Buffer Size</h2>
    <MadCap:snippetBlock src="Snippets/TCP-Send-Rec-Buf-Size.flsnp"/>
    <ul>
      <li><code>JCSMPChannelProperties.setSendBuffer(int)</code>; 64,000 bytes</li>
      <li><code>JCSMPChannelProperties.setReceiveBuffer(int)</code>; 64,000 bytes</li>
    </ul>
    <h2 class="with-rule"><a name="Do"/>Do Not Cache XMLMessages</h2>
    <p>If using messages from the producer message pool, always call <code>XMLMessageProducer.create&lt;TYPE&gt;XMLMessage()</code> to acquire a new <code>XMLMessage</code> instance for publishing. The application should not cache or reuse messages because the JCSMP may automatically recycle the messages.</p>
    <h2 class="with-rule"><a name="Ultra-Lo"/>Ultra-Low Latency</h2>
    <p>For ultra-low latency applications, you can enable the M<code>ESSAGE_CALLBACK_ON_REACTOR</code> Session property to reduce message latency. When this Session property is enabled, messages delivered asynchronously to an XMLMessageListener are delivered directly from the I/O thread instead of from the consumer notification thread.</p>
    <p>Although enabling this Session property reduces message latency, it also decreases the maximum message throughput.</p>
    <h2 class="with-rule"><a name="Session2"/>Session Establishment</h2>
    <h3><a name="Host2"/>Host Lists</h3>
    <MadCap:snippetBlock src="Snippets/Host-Lists.flsnp"/>
    <h3><a name="Client3"/>Client API Keep-alive</h3>
    <MadCap:snippetBlock src="Snippets/Client-API-keepalive.flsnp"/>
    <h3><a name="High2"/>High Availability Failover and Reconnect Retries</h3>
    <MadCap:snippetBlock src="Snippets/HA-Failover-Reconnect-Retries.flsnp"/>
    <h3><a name="Replicat3"/>Replication Failover and Reconnect Retries</h3>
    <MadCap:snippetBlock src="Snippets/Re-Fail-Reconn-Retry.flsnp"/>
    <h3><a name="Replicat4"/>Replication Failover and Session Re-Establishment</h3>
    <MadCap:snippetBlock src="Snippets/Rep-Fail-Sess-ReEstab.flsnp"/>
    <h3><a name="File2"/>File Descriptor Limitation</h3>
    <MadCap:snippetBlock src="Snippets/File-Des-Limit.flsnp"/>
    <h2 class="with-rule"><a name="Subscrip"/>Subscription Management</h2>
    <p>The following best practices can be used for managing subscriptions:</p>
    <ul>
      <li>If you are adding or removing a large number of subscriptions, set the Wait for Confirm flag (<code>JCSMPSession.WAIT_FOR_CONFIRM</code>) <i>only</i> on the final subscription. This ensures that all subscriptions have been processed by the event broker, and improves event broker performance.</li>
      <li>In the event of a Session disconnect, you can have the API reapply subscriptions that were initially added by the application when the Session is reconnected. To reapply subscriptions on reconnect, enable the Reapply Subscriptions Session property (<code>JCSMPProperties.REAPPLY_SUBSCRIPTIONS</code>). Using this setting is recommended.</li>
    </ul>
    <div class="Note">The following two scenarios show how <code>WAIT_FOR_CONFIRM</code> can affect subscriptions in the event of a subscription failure:<ul><li><p>If a subscription failure occurs,  <code>REAPPLY_SUBSCRIPTIONS</code> is set to true, and you subscribe to a topic <b>with</b> the <code>WAIT_FOR_CONFIRM</code> flag, the subscription <b>is not</b> reapplied on reconnection.</p></li><li><p>If a subscription failure occurs,  <code>REAPPLY_SUBSCRIPTIONS</code> is set to true, and you subscribe to a topic <b>without</b> the <code>WAIT_FOR_CONFIRM</code> flag, the subscription <b>is</b> reapplied on reconnection.</p></li></ul></div>
    <h2 class="with-rule"><a name="Sending"/>Sending Messages</h2>
    <p>When sending messages, you should consider the following best practices for the message ownership model that you are using—a session-independent message model or a session-dependent message model.</p>
    <p>For information on session-independent and session-dependent message ownership models, refer to <MadCap:xref href="Creating-Messages.htm#publishing_direct_messages_2102779381_618548">Message Ownership</MadCap:xref> for Direct messages and <MadCap:xref href="Creating-Messages-1.htm#Ownership">Message Ownership</MadCap:xref> for Guaranteed messages.</p>
    <h3><a name="best_practices_3532640973_262238"/>Sending Session-Independent Messages</h3>
    <p MadCap:conditions="Default.HideFromAllOutput">When using the session-independent message model, in which messages are allocated on demand, it is recommended that messages are pre-allocated and reused whenever possible. Frequent allocation and disposal of session‑independent messages can significantly impact the performance of an application.</p>
    <h4>Summary</h4>
    <p>Always use the session-independent message model when sending messages. The session-dependent message model is supported for backwards compatibility.</p>
    <h4>Practice Details</h4>
    <p>There is no performance penalty for using the session-independent message ownership model if the messages are preallocated and reused whenever possible.  Messages are allocated on-demand in the session-independent model.</p>
    <p>With the session-dependent model, the application must call <code>send</code> immediately after the creation of the message to avoid possible memory resource exhaustion. Furthermore, messages from the session dependent message pool may be automatically recycled after the initial use, hence preventing the created message from being reused.</p>
    <p>Refer to the <MadCap:xref href="../../API-Developer-Online-Ref-Documentation/java/index.html">JCSMP Reference</MadCap:xref> for information on how to send session-independent messages.</p>
    <h3><a name="best_practices_3532640973_280869"/>Sending Session-Dependent Messages</h3>
    <p>When using the session-dependent message model, in which messages are taken from the <code>Producer</code> message pool, you must publish using <code>send()</code> after the creation of <code>XMLMessage</code> to avoid exhaustion of resources. For example, the following code sample incorrectly allows execution to continue without the message being sent after acquiring it:</p>
    <pre class="Code" xml:space="preserve">while (keepPublishing)
			{
			TextMessage message = producer.createTextMessage();
			if (messageToPublish)
			{
			message.setText(“&lt;xml&gt;hello!&lt;/xml&gt;”);
			producer.send(message);
			}
		}</pre>
    <p>To ensure that resources are not exhausted, call the <code>send()</code> method immediately after creating <code>XMLMessage</code>. For example:</p>
    <pre class="Code" xml:space="preserve">while (keepPublishing)
			{
			TextMessage message = producer.createTextMessage();
			message.setText(“&lt;xml&gt;hello!&lt;/xml&gt;”);
			producer.send(message);
		}</pre>
    <p class="Note">The session-dependent message ownership model is primarily maintained for backwards compatibility with existing applications that use JCSMP. It is recommended that new Java applications use Session‑independent messages. There is no performance penalty for using the Session‑independent message ownership model if messages are pre-allocated and reused, whenever possible.</p>
    <h3><a name="Batch"/>Batch Send</h3>
    <h4>Recommendation</h4>
    <ul>
      <li>Use the batch sending facility to optimize send performance.  This is particularly useful for performance benchmarking a client application.</li>
    </ul>
    <p>Use the batch-sending facility to optimize send performance.  This is particularly useful for performance benchmarking client applications.</p>
    <p>A group of up to 50 messages can be sent through a single API call.  This allows messages to be sent in a batch.  The messages can be either Direct or Guaranteed. When batch-sending messages through the send-multiple API, the same Delivery mode, that is Direct or Persistent mode, should be set for all  messages in the batch. Messages in a batch can be set to different destinations.</p>
    <p>In addition to using the batch-sending API, messages should be pre-allocated and reused for batch-sending whenever possible. Specifically, don't reallocate new messages for each call to the batch-sending API.</p>
    <p>The batch-sending API call is <code>XMLMessageProducer.sendMultiple()</code>.</p>
    <h3><a name="High-Per"/>High-Performance Batch Sending</h3>
    <p>When batch sending messages, only use session-independent messages; do not use session-dependent messages. For information on session-independent and session-dependent message ownership models, refer to <MadCap:xref href="Creating-Messages.htm#publishing_direct_messages_2102779381_618548">Message Ownership</MadCap:xref> for Direct messages and <MadCap:xref href="Creating-Messages-1.htm#Ownership">Message Ownership</MadCap:xref> for Guaranteed messages.</p>
    <p>To optimize performance, it is also recommended that you preallocate messages and reuse them for batch sends whenever possible. (That is, avoid reallocating new messages for each call to <code>JCSMPSendMultipleEntry()</code>.)</p>
    <p>For more information on batch sending for Direct messages, refer to <MadCap:xref href="Sending-Messages.htm#publishing_direct_messages_2102779381_475505">Sending Multiple Messages at a Time</MadCap:xref>. For more information on batch sending for Guaranteed messages, refer to <MadCap:xref href="Sending-Messages.htm#publishing_direct_messages_2102779381_475505">Sending Multiple Messages at a Time</MadCap:xref>.</p>
    <h3><a name="Time-to-"/>Time-to-Live Messages</h3>
    <MadCap:snippetBlock src="Snippets/Time-To-Live-Msg.flsnp"/>
    <h2 class="with-rule"><a name="Receivin2"/>Receiving Messages</h2>
    <h3><a name="Handling"/>Handling Duplicate Message Publication</h3>
    <h4>Recommendation</h4>
    <ul>
      <li>Publishing duplicate messages can be avoided if the client application uses the Last Value Queue (LVQ) to determine the last message successfully spooled by the event broker upon restarting.</li>
    </ul>
    <p>When a client application is  unexpectedly restarted, it's possible for it to become out-of-sync with respect to the message publishing sequence.  There should be a mechanism by which it can determine the last message that was successfully published to, and received by, the event broker in order to correctly resume publishing without injecting duplicate messages.</p>
    <p>One approach is for the publishing application to maintain a database that correlates between the published message identifier and the acknowledgment it receives from the event broker.  This approach is completely self-contained on the client application side, but can introduce processing latencies if not well managed.</p>
    <p>Another approach is to make use of the Last Value Queue (LVQ) feature, where the LVQ stores the last message spooled on the queue. A publishing client application can then browse the LVQ to determine the last message spooled by the event broker.  This allows the publisher to resume publishing without introducing duplicate messages.</p>
    <p>Refer to <MadCap:xref href="../../Messaging/Guaranteed-Msg/Configuring-Queues.htm#Configur16">Configuring Max Spool Usage Values</MadCap:xref> for instructions on setting up LVQ.</p>
    <h3><a name="Handling2"/>Handling Redelivered Messages</h3>
    <h4>Recommendation</h4>
    <ul>
      <li>When consuming from endpoints, a client application should appropriately handle redelivered messages.</li>
    </ul>
    <p>When a client application restarts, unexpectedly or not, and rebinds to a queue, it may receive messages that it had already processed as well as acknowledged.  This can happen because the acknowledgment can be lost on route to the event broker due to network issues.  The redelivered messages will be marked with the <code>redelivered</code> flag.</p>
    <p>A client application that binds to a non-exclusive queue may also receive messages with the <code>redelivered</code> flag set, even though the messages are received by the client application for the first time.  This is due to other clients connecting to the same non-exclusive queue which disconnects without the application acknowledging the received messages.  These messages are then redelivered to other client applications that bind to the same non-exclusive queue.</p>
    <p>The consuming application should contain a message processing mechanism to handle the above mentioned scenarios.</p>
    <h3><a name="Dealing"/>Dealing with Unexpected Message Formats</h3>
    <h4>Recommendation</h4>
    <ul>
      <li>Client applications should be able to handle unexpected message formats.  In the case of consuming from endpoints, a client application should acknowledge received messages even if those messages are unexpectedly formatted.</li>
    </ul>
    <p>Client applications should be able to contend with unexpected message formats.  There shouldn't be any assumptions made about a message's payload; for example, a payload may contain an empty attachment.  Applications should be coded such that they will avoid crashing, as well as logging the message contents and sending an acknowledgment back to the event broker if using Guaranteed Messaging. If client applications crash without sending acknowledgments, then when they reconnect, the same messages will be redelivered causing the applications to fail again.</p>
    <h3><a name="Client"/>Client Acknowledgment</h3>
    <h4>Recommendation</h4>
    <ul>
      <li>Client Applications should acknowledge received messages as soon as they have completed processing those messages when client acknowledgment mode is used.</li>
    </ul>
    <p>Once an application has completed processing a message, it should acknowledge the receipt of the message to the event broker.  Only when the event broker receives an acknowledgment for a Guaranteed Message will the message be permanently removed from its message spool. If the client disconnects without sending acknowledgments for some received messages, then those messages will be redelivered.  For the case of an exclusive queue, those messages will be delivered to the next connecting client.  For the case of a non-exclusive queue, those messages will be redelivered to the other clients that are bound to the  queue.</p>
    <p>There are two kinds of acknowledgments:</p>
    <ul>
      <li><u>API (also known as Transport) Acknowledgment</u>.  This is an internal acknowledgment between the API and the event broker and isn't exposed to the application.  The Assured Delivery (AD) window size, acknowledgment timer, and the acknowledgment threshold settings control API Acknowledgment.  A message that isn't transport acknowledged will be automatically redelivered by the event broker.</li>
      <li><u>Application Acknowledgment</u>.  This acknowledgment mechanism is on top of the API Acknowledgment. Its primary purpose is to confirm that message processing has been completed, and  that the corresponding messages can be permanently removed from the event broker. There are two application acknowledgment modes: auto-acknowledgment and client acknowledgment. When auto-acknowledgment mode is used, the API automatically generates application-level acknowledgments on behalf of the application.  When client acknowledgment mode is used, the client application must explicitly send the acknowledgment for the message ID of each message received.</li>
    </ul>
    <p>Refer to the <MadCap:xref href="Receiving-Guaranteed-Messages.htm">Receiving Guaranteed Messages</MadCap:xref> for a more detailed discussion on the different acknowledgment modes.</p>
    <h3><a name="Consume"/>Consume Messages and Return From Callbacks As Soon As Possible</h3>
    <p>To ensure the highest possible message throughput, received messages should be consumed as soon as possible after receipt.</p>
    <p>When using <code>XMLMessageConsumer</code> in synchronous operating mode, the application should call <code>receive()</code> as often as possible to retrieve messages received by an <code>XMLMessageConsumer</code>. If too many messages accumulate in the Queue for <code>XMLMessageConsumer</code>, <code>XMLMessageConsumer</code> is deemed congested and message delivery is suspended.</p>
    <p>When using <code>XMLMessageConsumer</code> in asynchronous operating mode, the application should ensure that the callback methods defined in <code>XMLMessageListener</code> return promptly, so that the calling thread is not blocked from processing subsequent messages.</p>
    <p>The application should similarly return from API event callbacks as quickly as possible.</p>
    <h3><a name="Memory"/>Memory Management When Receiving Messages</h3>
    <p>The API dynamically allocates memory for each message received. If an application uses AUTO ACK mode, the API keeps a reference to the message until the message callback returns. The API then uses the reference to acknowledge the message, after which the message memory is eligible to be freed by the garbage collector. If the application is receiving Direct messages or is using CLIENT ACK mode, the API does not keep a reference to the message after calling the message callback. Provided the application does not create a new reference, the message memory is then eligible for garbage collection when the callback returns, and the reference it contains go out of scope.</p>
    <h2 class="with-rule"><a name="Queues"/>Queues and Flows</h2>
    <h3><a name="Receivin"/>Receiving One Message at a Time</h3>
    <MadCap:snippetBlock src="Snippets/One-message.flsnp"/>
    <h3><a name="Setting"/>Setting Temporary Endpoint Spool Size</h3>
    <MadCap:snippetBlock src="Snippets/Set-Temp-EP-Spool-Size.flsnp"/>
    <h3><a name="AD"/>AD Window Size and max-delivered-unacked-msgs-per-flow</h3>
    <MadCap:snippetBlock src="Snippets/AD-Window-Size.flsnp"/>
    <h3><a name="Number"/>Number of Flows and AD Window Size</h3>
    <MadCap:snippetBlock src="Snippets/Flows-and-AD-Window-Size.flsnp"/>
    <h2 class="with-rule"><a name="Error"/>Error Handling and Logging</h2>
    <h3><a name="Logging"/>Logging and Log Level</h3>
    <MadCap:snippetBlock src="Snippets/logging-and-log-level.flsnp"/>
    <h3><a name="Handling3"/>Handling Session Events / Errors</h3>
    <MadCap:snippetBlock src="Snippets/Session-Events-Errors.flsnp"/>
    <p>A number of these Session Events are feedback to the client application through exception handling. Refer to JCSMPException and its sub classes, JCSMPTransportException, JCSMPStateException, JCSMPOperationException, for detailed information. For instance, the JCSMPTransportException is raised after several (re)connection retries.</p>
    <table class="TableStyle-Table_Num" style="width: 624px;caption-side: top;mc-table-style: url('../../Resources/TableStyles/Table_Num.css');" cellspacing="0">
      <caption valign="top" style="padding-bottom: 3pt;">
        <p class="TblCaption">Session Events</p>
      </caption>
      <col style="width: 548px;" class="TableStyle-Table_Num-Column-Column1"/>
      <col style="width: 342px;" class="TableStyle-Table_Num-Column-Column1"/>
      <thead>
        <tr class="TableStyle-Table_Num-Head-Header1">
          <th class="TableStyle-Table_Num-HeadE-Column1-Header1">
                       Java (SessionEvent Enum)
                    </th>
          <th class="TableStyle-Table_Num-HeadD-Column1-Header1">Description</th>
        </tr>
      </thead>
      <tbody>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>DOWN_ERROR</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>The Session was established and then went down.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>RECONNECTED</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>The automatic reconnect of the Session was successful, and the Session
 was established again.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>RECONNECTING</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>The Session has gone down, and an automatic reconnect attempt is in
 progress.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyE-Column1-Body1">
            <p>SUBSCRIPTION_
  ERROR</p>
          </td>
          <td class="TableStyle-Table_Num-BodyD-Column1-Body1">
            <p>The application rejected a subscription (add or remove).</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>VIRTUAL_
  ROUTER_
  NAME_
  CHANGED</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>The appliance’s Virtual Router Name changed during a reconnect
 operation.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>UNKNOWN_
  TRANSACTED_
  SESSION_
  NAME</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>An attempt to re-establish a transacted session failed.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyB-Column1-Body1">
            <p>INCOMPLETE_
  LARGE_
  MESSAGE_
  RECEIVED</p>
          </td>
          <td class="TableStyle-Table_Num-BodyA-Column1-Body1">
            <p>Incomplete large message is received by the consumer due to not
 receiving all the segments in time.</p>
          </td>
        </tr>
      </tbody>
    </table>
    <h3><a name="Handling4"/>Handling Flow Events / Errors</h3>
    <MadCap:snippetBlock src="Snippets/Handling-Flow-Events-Errors.flsnp"/>
    <p>An error event is indicated by throwing on access a JCSMPFlowTransportException, and, in the case of a flow in asynchronous mode, the error condition is delivered to the XMLMessageListener’s onException().</p>
    <table style="width: 624px;caption-side: top;mc-table-style: url('../../Resources/TableStyles/Table_Num.css');" class="TableStyle-Table_Num" cellspacing="0">
      <caption valign="top" style="padding-bottom: 3pt;">
        <p class="TblCaption">Flow Events</p>
      </caption>
      <col style="width: 548px;" class="TableStyle-Table_Num-Column-Column1"/>
      <col style="width: 342px;" class="TableStyle-Table_Num-Column-Column1"/>
      <thead>
        <tr class="TableStyle-Table_Num-Head-Header1">
          <th class="TableStyle-Table_Num-HeadE-Column1-Header1">
                       Java (FlowEvent Enum)
                    </th>
          <th class="TableStyle-Table_Num-HeadD-Column1-Header1">Description</th>
        </tr>
      </thead>
      <tbody>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>FLOW_ACTIVE</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>The Flow has become active.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>FLOW_INACTIVE</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>The Flow has become inactive.</p>
          </td>
        </tr>
        <tr MadCap:conditions="" class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>FLOW_RECONNECTING</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>When Flow Reconnect is enabled, instead of an INACTIVE event, the API generates this event and attempts to rebind the Flow.</p>
            <p>If the Flow rebind fails, the API monitors the bind failure and terminates the reconnecting attempts with an INACTIVE unless the failure reason  is one of the following:</p>
            <ul>
              <li>Queue Shutdown</li>
              <li>Topic Endpoint Shutdown</li>
              <li>Service Unavailable</li>
            </ul>
            <p>For more information about Flow Reconnect, refer to <MadCap:xref href="Creating-Flows.htm#Flow">Flow Auto Reconnect</MadCap:xref>.</p>
          </td>
        </tr>
        <tr MadCap:conditions="" class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyB-Column1-Body1">
            <p>FLOW_RECONNECTED</p>
          </td>
          <td class="TableStyle-Table_Num-BodyA-Column1-Body1">The Flow has been successfully reconnected.</td>
        </tr>
      </tbody>
    </table>
    <h3><a name="Custom"/>Custom Handling of Reconnect Events</h3>
    <h4>Recommendation</h4>
    <ul>
      <li>A client application that uses the Session’s message consumer should also register a JCSMPReconnectEventHandler instance when acquiring the consumer to hook into the API’s reconnect logic.</li>
    </ul>
    <p>A client application that uses the Session’s message consumer - acquired through JCSMPSession.getMessageConsumer(JCSMPReconnectEventHandler.XMLMessageListener) - should also register a JCSMPReconnectEventHandler instance when acquiring that consumer. This handler receives callbacks before <code>preReconnect()</code> and after <code>postReconnect()</code> the client’s TCP connection is reconnected after a connection failure. Through <code>preReconnect()</code> and <code>postReconnect()</code>, the client application can execute a list of actions before and after JCSMP attempts to re-establish the connection, for instance, to notify other parties within the system of the connection failure.</p>
    <h3><a name="Notifica"/>Notification of Transport Events in Publish-Only Applications</h3>
    <h4>Recommendation</h4>
    <ul>
      <li>For publish-only applications, it's necessary to create an empty XMLMessageConsumer in order to receive events from JCSMPReconnectEventHandler such that transport layer events can be captured.</li>
    </ul>
    <p>The JCSMPReconnectEventHandler is only exposed through XMLMessageConsumer.  For publish-only applications that acquire XMLMessageProducer, it's necessary to create an empty XMLMessageConsumer in order to receives events from JCSMPReconnectEventHandler.  The consumer can be acquired through session.getMessageConsumer().  It need not be started by calling the consumer.start() method.  This way, transport layer events can be captured for publishing only applications.</p>
    <h2 class="with-rule"><a name="Message"/>Event Broker Configuration that Influences Client Application Behavior</h2>
    <h3><a name="Max"/>Max Redelivery</h3>
    <MadCap:snippetBlock src="Snippets/Max-Redelivery.flsnp"/>
    <h3><a name="Reject"/>Reject Message to Sender on Discard</h3>
    <MadCap:snippetBlock src="Snippets/Reject-Msg-Sender-Discard.flsnp"/>
  </body>
</html>
