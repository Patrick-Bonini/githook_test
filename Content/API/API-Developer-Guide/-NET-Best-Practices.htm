<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
  <head>
    <link href="../../Resources/TableStyles/Table_Num.css" rel="stylesheet" MadCap:stylesheetType="table"/>
  </head>
  <body>
    <h1>.NET API Best Practices</h1>
    <h2 class="with-rule"><a name="General"/>General Best Practices</h2>
    <h3><a name="Tuning"/>Tuning Guidelines for Guaranteed Messaging</h3>
    <MadCap:snippetBlock src="Snippets/Tune-Guide-Guarn-Msg.flsnp"/>
    <h3><a name="Reapply"/>Reapply Subscriptions</h3>
    <MadCap:snippetBlock src="Snippets/Reapply-Sub.flsnp"/>
    <h3><a name="Number2"/>Number of Flows and Guaranteed Message Window Size</h3>
    <MadCap:snippetBlock src="Snippets/Flow-Guarn-Msg-Win-Size.flsnp"/>
    <h3><a name="Minimum"/>Minimum Message Burst Size</h3>
    <MadCap:snippetBlock src="Snippets/Min-Msg-Burst-Size.flsnp"/>
    <h2 class="with-rule"><a name="Basic"/>Basic Rules</h2>
    <p>When programming using the .NET API, it's useful to remember the following basic rules: </p>
    <ul>
      <li>durable and non-temporary objects (such as durable endpoints) are created at the Factory level</li>
      <li>non‑durable and temporary objects are created at the Session level</li>
      <li>flows are created at the Session level</li>
    </ul>
    <h2 class="with-rule"><a name="Threadin"/>Threading</h2>
    <h3><a name="Selectin"/>Selecting a Threading Model</h3>
    <p>The .NET API uses Contexts that create and manage their own worker threads for organizing communications with event brokers. Each client application that uses the .NET API must contain a minimum of one Context, and each Context can contain one or more Sessions.</p>
    <p>Application developers using the .NET API can choose to create one or more Sessions within a Context. The decision on how to configure your Sessions in Contexts is an important consideration in application design, as it directly impacts factors such as CPU usage on application host machines, message latency, and throughput.</p>
    <h3><a name="Context"/>Context and Session Threading Model Considerations</h3>
    <MadCap:snippetBlock src="Snippets/Context-Session-Thread-Model-Consider.flsnp"/>
    <h2 class="with-rule" MadCap:conditions="Default.HideFromAllOutput"><a name="Selectin2"/>Selecting Blocking Modes</h2>
    <p MadCap:conditions="Default.HideFromAllOutput">Blocking and non-blocking modes are configurable Session property parameters. When creating a Session, an application can configure whether a blocking or non‑blocking mode is used when a connection is established, for a send operation, and for subscribe and unsubscribe operations. For a list of the available blocking mode Session properties, refer to <MadCap:xref href="../Messaging-APIs/dotNet-API/net-api-home.htm">C# / .NET API</MadCap:xref>.</p>
    <h3 MadCap:conditions="Default.HideFromAllOutput"><a name="Blocking"/>Blocking Send</h3>
    <p MadCap:conditions="Default.HideFromAllOutput">Send-blocking calls automatically limit the publishing rate at which the event broker can accept messages. Use non-blocking send to increase application performance.</p>
    <p MadCap:conditions="Default.HideFromAllOutput">In send-blocking mode, the calling thread for each send function call is blocked until the API accepts the message; hence the sending rate is automatically limited to the rate at which the event broker can accept the message. The send call remains blocked until either:</p>
    <ol>
      <li MadCap:conditions="Default.HideFromAllOutput">It is accepted by the API, or</li>
      <li MadCap:conditions="Default.HideFromAllOutput">the associated blocking write timeout expires.</li>
    </ol>
    <p MadCap:conditions="Default.HideFromAllOutput">Compared to non-blocking mode, send calls that cannot be accepted by the API immediately return a <code>would_block</code> error code to the client application. In the meantime, the client application can continue to process other actions. Subsequently, the API will receive a <code>can_send</code> event which signifies that the client application can retry the <code>send()</code> function call again.</p>
    <p MadCap:conditions="Default.HideFromAllOutput">The send blocking parameter is <code>SessionProperties.SendBlocking</code>.</p>
    <h2 class="with-rule"><a name="Memory"/>Memory Management</h2>
    <p>The following sections discuss how to manage memory in the .NET API and provide some guidelines for optimizing the performance of the API.</p>
    <h3><a name="best_practices_2265904997_251233"/>Modifying the Global Pool Buffer Sizes</h3>
    <p>The .NET API allocates specific sized buffers from its own pools and maintains them internally. Buffers are allocated from heap storage and used for saving messages in the application space until the message buffers are released by the application or later garbage collection.</p>
    <p>You can optionally modify the default global data buffer sizes for the five pools that are used when .NET API is initialized. </p>
    <p>When you call the <code>ContextFactory.Init(...)</code> method to initialize the .NET API, you can modify the following <code>ContextFactoryProperties</code>:</p>
    <ul>
      <li>
        <code>MaxPoolMemory</code>
        <p>Specifies maximum amount of memory the .NET API can save in its data and message pools.</p>
      </li>
      <li>
        <code>DBQuantaSize_&lt;0-4&gt;</code>
        <p>Specifies the size of the data buffers for each of the five pools. Once it reaches this size, datablocks are released back to heap and not kept in an API pool.</p>
      </li>
    </ul>
    <p>For more information, see the  <MadCap:xref href="../Messaging-APIs/dotNet-API/net-api-home.htm#C#/.NET">C#/.NET API Reference</MadCap:xref>.</p>
    <h3><a name="best_practices_2265904997_251225"/>Configuring Message Buffer Sizes</h3>
    <p>When creating a Session, an application can configure the following memory and resource allocation-related Session properties:</p>
    <ul>
      <li>
        <code>SessionProperties.SdkBufferSize</code>
        <p>The Session buffer size used for transmitting messages for the TCP Session. This parameter specifies the maximum amount of messages to buffer (as measured in bytes). For maximum performance, when sending small messages, the Session buffer size should be set to multiple times the typical message size.</p>
        <p>The .NET API always accepts at least one message to transmit. So even if the size of a single message exceeds the set buffer size, it is accepted and transmitted, as along as the current buffered data is zero. However, no further messages are accepted until the amount of data buffered is reduced below the set buffer size.</p>
      </li>
    </ul>
    <ul>
      <li>
        <code>SessionProperties.SocketReceiveBufferSizeInBytes</code>
        <p>The receive buffer size for the subscriber data socket. A default value of 150,000 is used. If this property is set to 0, then the receive buffer size uses the default operating system size.</p>
        <div class="Note">
          <p class="Tbl_Body">On Windows platforms the receive socket buffer size must be much larger than the send socket buffer sizes to prevent data loss when sending and receiving messages. For example, the default send socket and internal buffer sizes are set at 90,000, and the default receive socket buffer size is set at 150,000. If you change the default sizes, it is recommended that you maintain a similar sizing ratio.</p>
        </div>
      </li>
    </ul>
    <ul>
      <li>
        <code>SessionProperties.SocketSendBufferSizeInBytes</code>
        <p>Allows the send buffer size for the publisher data socket to be set by the application. A default value of 90,000 is used. If this property is set to 0, then the send buffer size uses the operating system default.</p>
        <div class="Note">
          <p class="Tbl_Body"> You can also modify the global data buffer sizes for the five pools of buffers used by the .NET API (<code>DBQuantaSize_&lt;0-4&gt;</code>). Modifying the global data buffer sizes can be done when you initialize the API. Refer to <MadCap:xref href="#best_practices_2265904997_251233">Modifying the Global Pool Buffer Sizes</MadCap:xref>.</p>
        </div>
      </li>
    </ul>
    <h3><a name="best_practices_2265904997_247428"/>Managing Memory When Publishing Messages</h3>
    <p>To ensure a high level of operational performance when publishing messages, you should avoid unnecessary memory moving and copying. Therefore it is recommended to reuse the message instances whenever possible.</p>
    <h3><a name="best_practices_2265904997_257319"/>Managing Memory When Receiving Messages</h3>
    <p>Received message buffers are owned by the application. To ensure that allocated memory is freed, it is recommended that you explicitly call the Dispose() method for each message received.</p>
    <h2 class="with-rule"><a name="Session"/>Session Establishment</h2>
    <h3><a name="Blocking2"/>Blocking Connect</h3>
    <MadCap:snippetBlock src="Snippets/Blocking-Connect.flsnp"/>
    <p>The blocking connect property is <code>SessionProperties.ConnectBlocking</code>.</p>
    <h3><a name="Host"/>Host Lists</h3>
    <MadCap:snippetBlock src="Snippets/Host-Lists.flsnp"/>
    <h3><a name="Client2"/>Client API Keep-alive</h3>
    <MadCap:snippetBlock src="Snippets/Client-API-keepalive.flsnp"/>
    <h3><a name="High"/>High Availability Failover and Reconnect Retries</h3>
    <MadCap:snippetBlock src="Snippets/HA-Failover-Reconnect-Retries.flsnp"/>
    <h3><a name="Replicat"/>Replication Failover and Reconnect Retries</h3>
    <MadCap:snippetBlock src="Snippets/Re-Fail-Reconn-Retry.flsnp"/>
    <h3><a name="Replicat2"/>Replication Failover and Session Re-Establishment</h3>
    <MadCap:snippetBlock src="Snippets/Rep-Fail-Sess-ReEstab.flsnp"/>
    <h3><a name="File"/>File Descriptor Limitation</h3>
    <MadCap:snippetBlock src="Snippets/File-Des-Limit.flsnp"/>
    <h2 class="with-rule"><a name="Subscrip"/>Subscription Management</h2>
    <p>The following best practices can be used for managing subscriptions:</p>
    <ul>
      <li>If you are adding or removing a large number of subscriptions, set the Wait for Confirm flag (<code>SubscribeFlag.WaitForConfirm</code>)on the final subscription to ensure that all subscriptions have been processed by the event broker. On all other subscriptions, to increase performance, it is recommended that the application not set Wait for Confirm.</li>
      <li>In the event of a Session disconnect, you can have the messaging API reapply subscriptions that were initially added by the application when the Session is reconnected. To reapply subscriptions on reconnect, enable the Reapply Subscriptions Session property (<code>SessionProperties.ReapplySubscriptions</code>). Using this setting is recommended.</li>
    </ul>
    <h2 class="with-rule"><a name="Sending"/>Sending Messages</h2>
    <h3><a name="Blocking3"/>Blocking Send</h3>
    <MadCap:snippetBlock src="Snippets/Blocking-Send.flsnp"/>
    <p>The send blocking parameter is <code>SessionProperties.SendBlocking</code>.</p>
    <h3><a name="Batch"/>Batch Send</h3>
    <h4>Recommendation</h4>
    <ul>
      <li>Use the batch sending facility to optimize send performance.  This is particularly useful for performance benchmarking a client application.</li>
    </ul>
    <p>Use the batch-sending facility to optimize send performance.  This is particularly useful for performance benchmarking client applications.</p>
    <p>A group of up to 50 messages can be sent through a single API call.  This allows messages to be sent in a batch.  The messages can be either Direct or Guaranteed. When batch-sending messages through the send-multiple API, the same Delivery mode, that is Direct or Persistent mode, should be set for all  messages in the batch. Messages in a batch can be set to different destinations.</p>
    <p>In addition to using the batch-sending API, messages should be pre-allocated and reused for batch-sending whenever possible. Specifically, don't reallocate new messages for each call to the batch-sending API.</p>
    <p>The batch-sending API call is <code>ISession.Send()</code>.</p>
    <h3><a name="Time-to-"/>Time-to-Live Messages</h3>
    <MadCap:snippetBlock src="Snippets/Time-To-Live-Msg.flsnp"/>
    <h2 class="with-rule"><a name="Receivin2"/>Receiving Messages</h2>
    <h3><a name="Handling"/>Handling Duplicate Message Publication</h3>
    <h4>Recommendation</h4>
    <ul>
      <li>Publishing duplicate messages can be avoided if the client application uses the Last Value Queue (LVQ) to determine the last message successfully spooled by the event broker upon restarting.</li>
    </ul>
    <p>When a client application is  unexpectedly restarted, it's possible for it to become out-of-sync with respect to the message publishing sequence.  There should be a mechanism by which it can determine the last message that was successfully published to, and received by, the event broker in order to correctly resume publishing without injecting duplicate messages.</p>
    <p>One approach is for the publishing application to maintain a database that correlates between the published message identifier and the acknowledgment it receives from the event broker.  This approach is completely self-contained on the client application side, but can introduce processing latencies if not well managed.</p>
    <p>Another approach is to make use of the Last Value Queue (LVQ) feature, where the LVQ stores the last message spooled on the queue. A publishing client application can then browse the LVQ to determine the last message spooled by the event broker.  This allows the publisher to resume publishing without introducing duplicate messages.</p>
    <p>Refer to <MadCap:xref href="../../Messaging/Guaranteed-Msg/Configuring-Queues.htm#Configur16">Configuring Max Spool Usage Values</MadCap:xref> for instructions on setting up LVQ.</p>
    <h3><a name="Handling2"/>Handling Redelivered Messages</h3>
    <p>When a client application restarts, unexpectedly or not, and rebinds to a queue, it may receive messages that it had already processed as well as acknowledged.  This can happen because the acknowledgment can be lost on route to the event broker due to network issues.  The redelivered messages will be marked with the <code>redelivered</code> flag.</p>
    <p>A client application that binds to a non-exclusive queue may also receive messages with the <code>redelivered</code> flag set, even though the messages are received by the client application for the first time.  This is due to other clients connecting to the same non-exclusive queue which disconnects without the application acknowledging the received messages.  These messages are then redelivered to other client applications that bind to the same non-exclusive queue.</p>
    <p>The consuming application should contain a message processing mechanism to handle the above mentioned scenarios.</p>
    <h3><a name="Dealing"/>Dealing with Unexpected Message Formats</h3>
    <h4>Recommendation</h4>
    <ul>
      <li>Client applications should be able to handle unexpected message formats.  In the case of consuming from endpoints, a client application should acknowledge received messages even if those messages are unexpectedly formatted.</li>
    </ul>
    <p>Client applications should be able to contend with unexpected message formats.  There shouldn't be any assumptions made about a message's payload; for example, a payload may contain an empty attachment.  Applications should be coded such that they will avoid crashing, as well as logging the message contents and sending an acknowledgment back to the event broker if using Guaranteed Messaging. If client applications crash without sending acknowledgments, then when they reconnect, the same messages will be redelivered causing the applications to fail again.</p>
    <h3><a name="Client"/>Client Acknowledgment</h3>
    <h4>Recommendation</h4>
    <ul>
      <li>Client Applications should acknowledge received messages as soon as they have completed processing those messages when client acknowledgment mode is used.</li>
    </ul>
    <p>Once an application has completed processing a message, it should acknowledge the receipt of the message to the event broker.  Only when the event broker receives an acknowledgment for a Guaranteed Message will the message be permanently removed from its message spool. If the client disconnects without sending acknowledgments for some received messages, then those messages will be redelivered.  For the case of an exclusive queue, those messages will be delivered to the next connecting client.  For the case of a non-exclusive queue, those messages will be redelivered to the other clients that are bound to the  queue.</p>
    <p>There are two kinds of acknowledgments:</p>
    <ul>
      <li><u>API (also known as Transport) Acknowledgment</u>.  This is an internal acknowledgment between the API and the event broker and isn't exposed to the application.  The Assured Delivery (AD) window size, acknowledgment timer, and the acknowledgment threshold settings control API Acknowledgment.  A message that isn't transport acknowledged will be automatically redelivered by the event broker.</li>
      <li><u>Application Acknowledgment</u>.  This acknowledgment mechanism is on top of the API Acknowledgment. Its primary purpose is to confirm that message processing has been completed, and  that the corresponding messages can be permanently removed from the event broker. There are two application acknowledgment modes: auto-acknowledgment and client acknowledgment. When auto-acknowledgment mode is used, the API automatically generates application-level acknowledgments on behalf of the application.  When client acknowledgment mode is used, the client application must explicitly send the acknowledgment for the message ID of each message received.</li>
    </ul>
    <p>Refer to the <MadCap:xref href="Receiving-Guaranteed-Messages.htm">Receiving Guaranteed Messages</MadCap:xref> for a more detailed discussion on the different acknowledgment modes.</p>
    <h2 class="with-rule"><a name="Do"/>Do Not Block in Callbacks</h2>
    <p>Applications must not block in and should return as quickly as possible from message receive, event and timer callbacks so that the calling thread can process the next message, event or timer and perform internal API housekeeping. The one exception is for transacted sessions. Applications can call API-provided blocking functions such as commit, rollback and send from within the message receive callback of a transacted session.</p>
    <h2 class="with-rule"><a name="Queues"/>Queues and Flows</h2>
    <h3><a name="Receivin"/>Receiving One Message at a Time</h3>
    <MadCap:snippetBlock src="Snippets/One-message.flsnp"/>
    <h3><a name="Setting"/>Setting Temporary Endpoint Spool Size</h3>
    <MadCap:snippetBlock src="Snippets/Set-Temp-EP-Spool-Size.flsnp"/>
    <h3><a name="AD"/>AD Window Size and max-delivered-unacked-msgs-per-flow</h3>
    <MadCap:snippetBlock src="Snippets/AD-Window-Size.flsnp"/>
    <h3><a name="Number"/>Number of Flows and AD Window Size</h3>
    <MadCap:snippetBlock src="Snippets/Flows-and-AD-Window-Size.flsnp"/>
    <h2 class="with-rule"><a name="Error2"/>Error Handling and Logging</h2>
    <h3><a name="Logging"/>Logging and Log Level</h3>
    <MadCap:snippetBlock src="Snippets/logging-and-log-level.flsnp"/>
    <h3><a name="Error"/>Error Handling</h3>
    <p>When .NET API Sessions are terminated unexpectedly, error information can be collected and sent to the application. The following Session event enumerations trigger error information:</p>
    <ul>
      <li><code>DownError</code>—The Session was established and then went down.</li>
      <li><code>ConnectFailedError</code>—The Session attempted to connect but was unsuccessful.</li>
      <li><code>RejectedMessageError</code>—The event broker rejected a published message.</li>
      <li><code>SubscriptionError</code>—The event broker rejected a subscription add or remove.</li>
      <li><code>MessageTooBigError</code>—The API discarded a received message that exceeded the set Session buffer size.</li>
      <li><code>TEUnsubscribeError</code>—The Topic Endpoint unsubscribe request was successful.</li>
    </ul>
    <p class="Note">Error information is handled separately for each individual thread.</p>
    <p>To configure error handling, include calls to the following method in your event handling code:</p>
    <ul>
      <li><code>GetLastSDKErrorInfo()</code> on <code>ContextFactory</code> singleton
			<p>Returns a <code>SDKErrorInfo</code>, which contains the last captured error information for the calling thread.</p></li>
    </ul>
    <h3><a name="Subcodes"/>Subcodes</h3>
    <p>Subcodes provide more detailed error information. The basic subcodes that can result from any API call are listed in .</p>
    <p>Some API calls can also generate more specific error subcodes. For more information on these subcodes, refer to <MadCap:xref href="../Messaging-APIs/dotNet-API/net-api-home.htm#C#/.NET">C#/.NET API Reference</MadCap:xref>.</p>
    <p>The last generated subcode is stored on a per-thread basis and can be retrieved by an application thread.</p>
    <table class="TableStyle-Table_Num" style="caption-side: top;mc-table-style: url('../../Resources/TableStyles/Table_Num.css');" cellspacing="0">
      <caption valign="top" style="padding-bottom: 3pt;">
        <p class="TblCaption">Generic Subcodes</p>
      </caption>
      <col class="TableStyle-Table_Num-Column-Column1"/>
      <col class="TableStyle-Table_Num-Column-Column1"/>
      <thead>
        <tr class="TableStyle-Table_Num-Head-Header1">
          <th class="TableStyle-Table_Num-HeadE-Column1-Header1">Subcode</th>
          <th class="TableStyle-Table_Num-HeadD-Column1-Header1">Description</th>
        </tr>
      </thead>
      <tbody>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p class="Tbl_BodyCode">FactoryInitNotCalled</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p class="Tbl_Body">An API call failed because <code>ContextFactory.Init()</code> was not first called.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p class="Tbl_BodyCode">ParamOutOfRange</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p class="Tbl_Body">An API call was made with an out-of-range parameter.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p class="Tbl_BodyCode">ParamConflict</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p class="Tbl_Body">An API call was made with an invalid parameter combination.</p>
            <p class="Note">This subcode only applies to methods that have interdependent parameters.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyE-Column1-Body1">
            <p class="Tbl_BodyCode">InternalError</p>
          </td>
          <td class="TableStyle-Table_Num-BodyD-Column1-Body1">
            <p class="Tbl_Body">An API call had an internal error (not an application fault).</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p class="Tbl_BodyCode">OperatingSystemError</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p class="Tbl_Body">An API call failed because of a failed operating system call.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyB-Column1-Body1">
            <p class="Tbl_BodyCode">OutOfMemory</p>
          </td>
          <td class="TableStyle-Table_Num-BodyA-Column1-Body1">
            <p class="Tbl_Body">An API call failed because memory could not be allocated.</p>
          </td>
        </tr>
      </tbody>
    </table>
    <h3><a name="Handling3"/>Handling Session Events / Errors</h3>
    <MadCap:snippetBlock src="Snippets/Session-Events-Errors.flsnp"/>
    <table class="TableStyle-Table_Num" style="width: 624px;caption-side: top;mc-table-style: url('../../Resources/TableStyles/Table_Num.css');" cellspacing="0">
      <caption valign="top" style="padding-bottom: 3pt;">
        <p class="TblCaption">Session Events</p>
      </caption>
      <col style="width: 548px;" class="TableStyle-Table_Num-Column-Column1"/>
      <col style="width: 342px;" class="TableStyle-Table_Num-Column-Column1"/>
      <thead>
        <tr class="TableStyle-Table_Num-Head-Header1">
          <th class="TableStyle-Table_Num-HeadE-Column1-Header1">.NET
  (SessionEvent Enum)</th>
          <th class="TableStyle-Table_Num-HeadD-Column1-Header1">Description</th>
        </tr>
      </thead>
      <tbody>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>Acknowledgment</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>The oldest transmitted Persistent/Non Persistent message that has been
 acknowledged.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>AssuredDeliveryDown</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>Guaranteed Delivery Publishing is not available.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>CanSend</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>The send is no longer blocked.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyE-Column1-Body1">
            <p>ConnectFailedError</p>
          </td>
          <td class="TableStyle-Table_Num-BodyD-Column1-Body1">
            <p>The Session attempted to connect but was unsuccessful.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>DownError</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>The Session was established and then went down.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>DTEUnsubscribeError</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>Deprecated name. Same as TE_UNSUBSCRIBE_ERROR.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>DTEUnsubscribeOK</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>Deprecated name. Same as TE_UNSUBSCRIBE_OK.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyE-Column1-Body1">
            <p>ModifyPropertyFail</p>
          </td>
          <td class="TableStyle-Table_Num-BodyD-Column1-Body1">
            <p>The session property modification failed.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>MOdifyPropertyOK</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>The session property modification completed.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>ProvisionError</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>The endpoint create/delete command failed.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>ProvisionOK</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>The endpoint create/delete command completed.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyE-Column1-Body1">
            <p>Reconnected</p>
          </td>
          <td class="TableStyle-Table_Num-BodyD-Column1-Body1">
            <p>The automatic reconnect of the Session was successful, and the Session
 was established again.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>Reconnecting</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>The Session has gone down, and an automatic reconnect attempt is in
 progress.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>RejectMessageError</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>The appliance rejected a published message.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>ReplublishUnacked
  Messages</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>After successfully reconnecting a disconnected session, the API
 received an unknown publisher flow name response when reconnecting the
 Guaranteed Delivery publisher flow.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyE-Column1-Body1">
            <p>MessageTooBigError</p>
          </td>
          <td class="TableStyle-Table_Num-BodyD-Column1-Body1">
            <p>The API discarded a received message that exceeded the Session buffer
 size.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>SubscriptionError</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>The application rejected a subscription (add or remove).</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>SubscriptionOK</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>The subscribe or unsubscribe operation has succeeded.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>TEUnsubscribeError</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>The Topic Endpoint unsubscribe command failed.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyE-Column1-Body1">
            <p>TEUnsubscribeOK</p>
          </td>
          <td class="TableStyle-Table_Num-BodyD-Column1-Body1">
            <p>The Topic Endpoint unsubscribe completed.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>UpNotice</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>The Session is established</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyB-Column1-Body1">
            <p>VirtualRouter
  NameChanged</p>
          </td>
          <td class="TableStyle-Table_Num-BodyA-Column1-Body1">
            <p>The appliance’s Virtual Router Name changed during a reconnect
 operation.</p>
          </td>
        </tr>
      </tbody>
    </table>
    <h3><a name="Handling4"/>Handling Flow Events / Errors</h3>
    <MadCap:snippetBlock src="Snippets/Handling-Flow-Events-Errors.flsnp"/>
    <table class="TableStyle-Table_Num" style="width: 624px;caption-side: top;mc-table-style: url('../../Resources/TableStyles/Table_Num.css');" cellspacing="0">
      <caption valign="top" style="padding-bottom: 3pt;">
        <p class="TblCaption">Flow Events</p>
      </caption>
      <col style="width: 548px;" class="TableStyle-Table_Num-Column-Column1"/>
      <col style="width: 342px;" class="TableStyle-Table_Num-Column-Column1"/>
      <thead>
        <tr class="TableStyle-Table_Num-Head-Header1">
          <th class="TableStyle-Table_Num-HeadE-Column1-Header1">.NET
  (FlowEvent Enum)</th>
          <th class="TableStyle-Table_Num-HeadD-Column1-Header1">Description</th>
        </tr>
      </thead>
      <tbody>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>UpNotice</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>The Flow is established</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>DownError</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>The Flow was established and then disconnected by the appliance, likely
 due to operator intervention.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>BindFailedError</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>The Flow attempted to connect but was unsuccessful.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyE-Column1-Body1">
            <p>ParentSessionDown</p>
          </td>
          <td class="TableStyle-Table_Num-BodyD-Column1-Body1">
            <p>The Session for the Flow was disconnected.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>FlowActive</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>The Flow has become active.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>FlowInactive</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>The Flow has become inactive.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1" MadCap:conditions="">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">
            <p>Reconnecting</p>
          </td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>When Flow Reconnect is enabled, instead of a DownError event, the API generates this event and attempts to rebind the Flow.</p>
            <p>If the Flow rebind fails, the API monitors the bind failure and terminates the reconnecting attempts with a DownError unless the failure reason  is one of the following:</p>
            <ul>
              <li>Queue Shutdown</li>
              <li>Topic Endpoint Shutdown</li>
              <li>Service Unavailable</li>
            </ul>
            <p>For more information about Flow Reconnect, refer to <MadCap:xref href="Creating-Flows.htm#Flow">Flow Auto Reconnect</MadCap:xref>.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1" MadCap:conditions="">
          <td class="TableStyle-Table_Num-BodyB-Column1-Body1">
            <p>Reconnected</p>
          </td>
          <td class="TableStyle-Table_Num-BodyA-Column1-Body1">
            <p>The Flow has been successfully reconnected.</p>
          </td>
        </tr>
      </tbody>
    </table>
    <h2 class="with-rule"><a name="Message"/>Event Broker Configuration that Influences Client Application Behavior</h2>
    <h3><a name="Max"/>Max Redelivery</h3>
    <MadCap:snippetBlock src="Snippets/Max-Redelivery.flsnp"/>
    <h3><a name="Reject"/>Reject Message to Sender on Discard</h3>
    <MadCap:snippetBlock src="Snippets/Reject-Msg-Sender-Discard.flsnp"/>
  </body>
</html>
