<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
  <head/>
  <body>
    <h1>Creating Message Consumers</h1>
    <p>A <code>MessageConsumer</code> object can be used to receive messages from a queue or for a specific topic. The common <code>MessageConsumer</code> interface behaves in the same manner as its respective sub‑interfaces <code>QueueReceiver</code> and <code>TopicSubscriber</code>, which are PTP- and pub/sub-specific interfaces.</p>
    <p>To create a message consumer in a Session, call the <code>session.createConsumer(...)</code> method and pass in a queue or topic destination.</p>
    <p>To create a message consumer in an XA Session, rather than a non‑transacted local Session, call the <code>XASession.createConsumer(...)</code> method and pass in queue or topic.</p>
    <p>Once a message consumer is created, it becomes active and can be used to receive messages on a connection that is started. Call <code>close()</code> to close the message consumer.</p>
    <h2 class="with-rule"><a name="receiving_messages_3569307012_320577"/>Message Consumer Durability</h2>
    <p>When consuming messages from a queue, the durability of the message consumer depends on the durability of the queue. For example, if the queue is durable, then the message consumer is also durable. For more information on the durability of destinations, refer to <MadCap:xref href="Working-with-Destination.htm">Working with Destinations</MadCap:xref>.</p>
    <p style="margin-top: 0pt;margin-bottom: 0pt;">When consuming messages for a given topic, the created topic subscriber is always non‑durable. That is, the implicitly‑created subscriber can only receive messages published to the topic when it is connected; messages are not spooled when the subscriber disconnects.</p>
    <p class="Note" MadCap:autonum="&lt;b&gt;Note:  &lt;/b&gt;">If you want to create a durable topic subscriber, you can use the <code>createDurableSubscriber(...)</code> method (refer to <MadCap:xref href="Creating-Durable-Topic-S.htm">Creating Durable Topic Subscribers</MadCap:xref>).</p>
    <p>For durable consumers and durable topic subscribers, the clients are bound to the durable queue and topic-endpoint.</p>
    <p>For non-durable consumers (that is, consumers bound to temporary queues and non‑durable topic subscribers), temporary topic-endpoints and queues are automatically created for the consumers.</p>
    <h2 class="with-rule"><a name="receiving_messages_3569307012_320645"/>Selectively Receiving Messages</h2>
    <p>A message consumer can also use the following features to fine-tune the messages it will receive:</p>
    <ul>
      <li><code>messageSelector</code>—A message selector can be passed in to restrict the messages that are delivered when a Guaranteed Transport mode is used. A message selector uses header field references and property references to specify what messages a message consumer is interested in. For more information, refer to <MadCap:xref href="Selectors.htm#receiving_messages_3569307012_300923">Selectors</MadCap:xref>.</li>
      <li><code>noLocal</code>—The <code>noLocal</code> attribute can be enabled to prevent the delivery of messages published on the same connection used by the consumer. For example, it is possible that on a single connection, a client publishes messages to the same Topic that it is consuming messages for.</li>
    </ul>
    <p>To create a durable <code>MessageConsumer</code> with a message selector and the <code>noLocal</code> attribute, call the <code>createConsumer(Destination destination, java.lang.String messageSelector, boolean noLocal)</code> method.</p>
    <p class="Note" MadCap:autonum="&lt;b&gt;Note:  &lt;/b&gt;">When the Direct Transport mode is used, a message selector or the <code>NoLocal</code> attribute cannot be used when a non-durable consumer is created. A configuration exception is returned.</p>
    <h2 class="with-rule"><a name="receiving_messages_3569307012_306598"/>Receiving Active/Inactive Indications for Exclusive Queue Consumers</h2>
    <p>When a queue has an exclusive access type, multiple message consumers can be bound to that queue, but only one message consumer can actively receive messages.</p>
    <p>If you want to receive notifications as to whether a message consumer that is bound to a queue is actively receiving messages (that is, it has an active flow) or if it is not actively receiving messages (that is, it has an inactive flow), you can use a Solace-specific <code>com.solacesystems.jms.SolEventSource</code> interface that allows JMS applications to register event listeners for events of interest, such as active flow indication.</p>
    <p>From this interface, call <code>addSolEventListener(...)</code> and pass in an <code>SolEventListener</code> that the client application can use to handle any returned SolEvents that indicate whether the message consumer has an active or inactive flow to a queue.</p>
    <p>The <code>com.solacesystems.jms.SolEventListener</code> interface relies on the following method to handle SolEvents:</p>
    <p class="Code">com.solacesystems.jms.SolEventListener.handleEvent(SolEventSource source, SolEvent event)
        </p>
    <p><u>Where</u>:</p>
    <p><code>SolEventSource</code> is the source of the SolEvents. For active flow indications, this is the message consumer.</p>
    <p><code>SolEvent</code> is the Solace proprietary event that is returned. For active flow indications, it is an <code>ActiveFlowIndicationEvent</code> that returns one of the following constants that indicate whether the message consumer has an active flow:</p>
    <ul>
      <li>0—Flow is inactive</li>
      <li>1—Flow is active</li>
    </ul>
    <p class="Note" MadCap:autonum="&lt;b&gt;Note:  &lt;/b&gt;">To de-register or remove the <code>SolEventListener</code> instance, call <code>remove<br/>SolEventListener()</code>.</p>
    <p>The following code snippet shows how to use the SolEvent JMS interface to receive active/inactive flow indications for exclusive queue consumers:</p>
    <p class="Code">// session is a valid javax.jms.Session and queue is a valid javax.jms.Queue<br/>         consumer = session.createConsumer(queue);<br/>  <br/>try {<br/>SolEventSource evtSource = (SolEventSource)consumer;<br/>evtSource.addSolEventListener(new SolEventListener() {<br/>public void handleEvent(SolEventSource source, SolEvent evt) {<br/>ActiveFlowIndicationEvent afiEvent = <br/> (ActiveFlowIndicationEvent) evt;<br/>if (evt.getFlowState() == <br/>ActiveFlowIndicationEvent. FLOW_ACTIVE) {<br/>// Take action here<br/>}<br/>}<br/>}, SolEvent.SOLEVENT_TYPE_ACTIVE_FLOW_INDICATION);<br/>} catch (ClassCastExcetpion ex) {<br/>ex.printStackTrace();<br/>}</p>
    <p>
      <b>Related Sample</b>
    </p>
    <p>For a more complete example of how to use the SolEvent JMS interface to receive active/inactive flow indications for exclusive queue consumers, refer to the <code>SolJMSActiveFlowIndication</code> sample.</p>
  </body>
</html>
