<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
  <head>
    </head>
  <body>
    <h1><a name="Consuming-Direct-Messages-Java-API"/>Consuming Direct Messages Using the Go API </h1>
    <p> Direct messaging is useful in scenarios where high-throughput and low-latency is required.  It is possible with the use of direct messages that some  message loss may occur due to external factors, such as network congestion or occasional client disconnections. Direct messages are suitable for applications that need the latest information but not necessarily every single message. Examples of these applications may be weather applications, price checkers, GPS tracking, and so on.</p>
    <p>  No additional event broker configuration is required for direct messaging. If your application cannot tolerate message loss, we recommend that you use persistent messaging. </p>
    <p>To consume direct messages using the <MadCap:variable name="Product-Names.pubsub_brand_only"/> Go API, use the following steps:</p>
    <ol>
      <li><a href="#Creating-A-DirectMessageReceiver-Object" class="link-internal">Create a DirectMessageReceiver</a>.</li>
      <li><a href="#Configuring-Back-Pressure" class="link-internal">Handling Back-Pressure When Subscribing to Direct Messages</a>.</li>
      <li><a href="#Receiving-A-Direct-Message-Synchronously" class="link-internal">Receive a Direct Message Synchronously</a>.</li>
      <li><a href="#Receiving-A-Direct-Message-Asynchronously" class="link-internal">Receive a Direct Message Asynchronously</a>.</li>
      <li><a href="#Extract-Message-Props" class="link-internal">Extract Properties from an Inbound Message</a>.</li>
    </ol>
    <p>In some use cases, the API receives messages from the event broker faster than your application can process them. Messages can fill in the API's internal buffers causing <i>back-pressure</i>. If this scenario is possible, you may want to consider changing the default back-pressure settings to meet your requirements. For more information, see  <MadCap:xref href="#Configuring-Back-Pressure">Configuring Back-pressure</MadCap:xref>.</p>
    <p>For examples of applications  that consume direct messages, see <a href="https://github.com/SolaceSamples/solace-samples-go/blob/main/patterns/direct_subscriber.go" class="link-offsite">direct_subscriber.go</a> on the <MadCap:variable name="Variables.CompanyName"/> GitHub page.</p>
    <h2><a name="Creating-A-DirectMessageReceiver-Object"/>Creating a DirectMessageReceiver </h2>
    <p>After a <code>MessagingService</code> instance has established a connection to an event broker, use a <code>DirectMessageReceiver</code>  to consume direct messages from the event broker.</p>
    <p>You can use a <code>DirectMessageReceiverBuilder</code> to configure your <code>DirectMessageReceiver</code> to use certain features of the API, such as topic subscriptions and back-pressure strategies. Calling the  <code>Build()</code> function on your <code>DirectMessageReceiverBuilder</code> returns a <code>DirectMessageReceiver</code> instance. To enable your <code>DirectMessageReceiver</code> to start receiving messages, call <code>Start()</code> on it.</p>
    <p>For more information,  see the <a href="../../API-Developer-Online-Ref-Documentation/go/index.html" class="link-internal"><MadCap:variable name="Product-Names.pubsub_brand_only"/> Messaging API for Go reference</a>.</p>
    <p>The following is an example that shows how to add subscriptions to topics to a  <code>DirectMessageReceiver</code> and connect to the event broker:</p>
    <pre xml:space="preserve">
directReceiver, err := messagingService.
	CreateDirectMessageReceiverBuilder().  // Creates a DirectMessageReceiverBuilder that can be used to configure direct message receiver instances.
	WithSubscriptions(topicsSub...).       // Sets a list of TopicSubscriptions to subscribe to when starting the receiver.
	Build()                                // Creates a DirectMessageReceiver with the specified properties.

if err != nil {
	panic(err)
}

if err := directReceiver.Start(); err != nil { // Starts the receiver synchronously. Before this function is called, the receiver is considered off-duty.
	panic(err)
}		</pre>
    <h3>Asynchronous Receivers </h3>
    <p>Alternatively, it's  possible to start a direct message receiver using a callback listener to allow for asynchronous notifications when the start operation is complete. </p>
    <p>The following example shows how to start the <code>DirectMessageReceiver</code> asynchronously:</p>
    <pre xml:space="preserve">
func ReceiverCallback(receiver solace.DirectMessageReceiver, err error) {
	if err != nil {
		panic(err) // receiver started up with an error
	} else {
		// receiver started without issue
	}
}
// ...	
// ...
directReceiver.StartAsyncCallback(ReceiverCallback) // Starts the receiver asynchronously. Calls the callback when started with an error if one occurred, otherwise nil if successful.</pre>
    <p class="Note">Your receiver application is not operational until you call <code>Start()</code> or <code>StartAsyncCallback()</code> on it.</p>
    <h2 class="with-rule"><a name="Configuring-Back-Pressure"/>Handling Back-Pressure When Subscribing to Direct Messages</h2>
    <MadCap:snippetBlock src="../../Resources/Snippets/API-Guide/NG-API/backpressureintro-consumer-direct-messages.flsnp"/>
    <p>In the <MadCap:variable name="Product-Names.pubsub_brand_only"/> Go API, the <code>DirectMessageReceiver</code> has the following mechanisms to handle back-pressure:</p>
    <ul>
      <li>
        <a href="#drop-latest" class="link-internal">drop the latest message</a>
      </li>
      <li>
        <a href="#drop-oldest" class="link-internal">drop the oldest message</a>
      </li>
    </ul>
    <p>
      <h3><a name="drop-latest"/>Dropping the Latest Message</h3>
    </p>
    <p>The default behavior of the Go API is to drop the latest message when 50  messages accumulate in the API's internal buffer. When this capacity is reached, the most recent messages are not placed on the internal buffer because it is full and are instead dropped (lost). </p>
    <p> To configure a different buffer size, call the <code>OnBackPressureDropLatest(bufferSize uint)</code> function on the <code>DirectMessageReceiverBuilder</code> and then set the maximum number of messages that can accumulate ( <code>bufferSize</code>) before messages are dropped. </p>
    <p>The following example shows how to configure the application to drop messages if there are a thousand messages queued in the API's internal buffer:</p>
    <pre xml:space="preserve">/* Creates an instance of DirectMessageReceiverBuilder, which is used to create DirectMessageReceivers. */
directReceiver, builderError := messagingService. 
	CreateDirectMessageReceiverBuilder(). // Creates a DirectMessageReceiverBuilder that can be used to configure direct message receiver instances.
	OnBackPressureDropLatest(1000).        // If the buffer is full and a message arrives, the incoming message is discarded.
	Build()                               // Creates a new DirectMessageReceiver instance based on the configured properties.
if builderErr != nil {
	panic(builderErr)
}

startErr := directReceiver.Start()    // Start starts the receiver synchronously. Before this function is called, the receiver is considered off-duty.
if startErr != nil {
	panic(startErr)
} </pre>
    <p>
      <h3><a name="drop-oldest"/>Dropping the Oldest Message</h3>
    </p>
    <p>You can configure the API to drop the oldest message when a specified capacity is reached in the API's internal buffer. When this capacity is reached, the oldest item is removed from the internal queue to make room to receive the newer message. When the specified capacity is reached,  the oldest items received by the receiver are removed to allow for more recent messages to be queued.</p>
    <p>To configure this mechanism, call the <code>OnBackPressureDropOldest(bufferSize uint)</code> function on the <code>DirectMessageReceiverBuilder</code> and then set the maximum number of messages that can accumulate ( <code>bufferSize</code>) before the oldest messages are removed from the internal buffer. </p>
    <p>The following example shows how to configure the application to drop the oldest message in the API's internal buffer if there are a thousand messages queued:</p>
    <pre xml:space="preserve">/* Creates an instance of DirectMessageReceiverBuilder, which is used to create DirectMessageReceivers. */
directReceiver, builderError := messagingService. 
	CreateDirectMessageReceiverBuilder(). // Creates a DirectMessageReceiverBuilder that can be used to configure direct message receiver instances.
	OnBackPressureDropOldest(1000).        // If the buffer is full and a message arrives, the oldest message in the buffer is discarded.
	Build()                               // Creates a new DirectMessageReceiver instance based on the configured properties.
if builderErr != nil {
	panic(builderErr)
}

startErr := directReceiver.Start()    // Start starts the receiver synchronously. Before this function is called, the receiver is considered off-duty.
if startErr != nil {
	panic(startErr)
}  </pre>
    <h2 class="with-rule"><a name="Receiving-A-Direct-Message-Synchronously"/>Receiving a Direct Message Synchronously </h2>
    <p>After you have established a connection to the event broker using a <code>MessagingService</code> instance, you can use a <code>DirectMessageReceiver</code> to subscribe to messages. The <code>DirectMessageReceiver</code> must be subscribed to at least one topic for it to begin receiving messages. </p>
    <p>The following   example shows how an  <code>InboundMessage</code> is received by the <code>DirectMessageReceiver</code>, and how the <code>ReceiveMessage()</code> function blocks the routine until the next message has been received:            </p>
    <pre xml:space="preserve">// ReceiveMessage waits until the specified timeout to receive a message, or will wait forever if the timeout specified is a negative value
var receivedMessage message.InboundMessage
var regErr solace.Error
if receivedMessage, regErr = directReceiver.ReceiveMessage(1 * time.Second); regErr != nil {
	panic(regErr)
} else {
	// Process the received message
}
</pre>
    <h2 class="with-rule"><a name="Receiving-A-Direct-Message-Asynchronously"/>Receiving a Direct Message Asynchronously </h2>
    <p>After you have established a connection to the event broker using a <code>MessagingService</code> instance, you can consume direct messages and handle them asynchronously using a <code>DirectMessageReceiver</code>. To handle direct messages asynchronously, you use  a <code>MessageHandler</code> to act as a callback function to let the application know when a message has been received.</p>
    <p> The following example shows how to receive messages asynchronously:</p>
    <pre xml:space="preserve">
// Register Message callback handler to the Message Receiver
if regErr := directReceiver.ReceiveAsync(MessageHandler); regErr != nil {
panic(regErr)
}
			
// Message Handler
func MessageHandler(message message.InboundMessage) {
	// Process the received message
}
</pre>
    <h2 class="with-rule"><a name="Extract-Message-Props"/>Extracting Properties from an Inbound Message</h2>
    <p>After you establish a connection to the event broker, your receiver application can subscribe to topics. Whenever your application receives a message from the broker with a matching topic, an <code>InboundMessage</code> instance is returned to the application. You can extract a number of properties from an <code>InboundMessage</code>, such as the message payload (as bytes or a string), and sender ID. The following examples show how to extract properties from a message.</p>
    <ul>
      <li>
        <p>Use a <code>MessageHandler</code> callback when you receive a message asynchronously:</p>
        <pre xml:space="preserve">
func MessageHandler(message message.InboundMessage) {
	var messagePayload string
	var senderID string
	if payload, ok := receivedMessage.GetPayloadAsString(); ok { // Extract the payload from a received message.
		messagePayload = payload
	}
	if senderID, ok := receivedMessage.GetSenderID(); ok {       // Extract the sender ID from a received message.
		senderID = senderID
	}
}				</pre>
      </li>
      <li>
        <p>Use the <code>ReceiveMessage()</code> function when you receive a message synchronously:</p>
        <pre xml:space="preserve">var receivedMessage message.InboundMessage
var regErr solace.Error
if receivedMessage, regErr = directReceiver.ReceiveMessage(1 * time.Second); regErr != nil {
	panic(regErr)
} else {
	var messagePayload string
	var senderID string
	if payload, ok := receivedMessage.GetPayloadAsString(); ok {   // Extract the payload from a received message.
		messagePayload = payload
	}
	if senderID, ok := receivedMessage.GetSenderID(); ok {         // Extract the sender ID from a received message.
		senderID = senderID
	}
}		</pre>
      </li>
    </ul>
    <p>For a complete list of functions that you can use to extract properties from an <code>InboundMessage</code>, see the <a href="../../API-Developer-Online-Ref-Documentation/go/index.html" class="link-internal"><a href="../../API-Developer-Online-Ref-Documentation/go/index.html" class="link-internal"><MadCap:variable name="Product-Names.pubsub_brand_only"/> Messaging API for Go reference</a></a>.</p>
  </body>
</html>
