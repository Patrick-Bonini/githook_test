<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
  <head>
    </head>
  <body>
    <h1><a name="top"/>Request-Reply Messaging in the Go API</h1>
    <p>Request-reply messaging is a method of data transmission where applications simulate separate point-to-point channels: one for requests, and another for replies. In request-reply messaging, each request sent from a <i>message requestor</i> requires a reply from a <i>message replier</i>. When a message replier consumes a request message, it sends a reply back to the requestor. This messaging pattern is useful when each message sent between components in your applications requires a reply, for example when performing authentication or financial transactions. </p>
    <p>
      <img src="../API-Developer-Guide/Images/request-reply-2.png"/>
    </p>
    <p>The  <MadCap:variable name="Manifest-Products-APIs.PubSub-GenericAll-Messaging-API"/>s publish request messages with a unique, automatically generated ReplyTo destination topic in the message header field. This ReplyTo topic serves as the return address that the reply should be sent to. Because the ReplyTo topic destination is handled by the <MadCap:variable name="Manifest-Products-APIs.PubSub-GenericAll-Messaging-API"/>s, it allows users to perform request-reply operations without worrying about registering appropriate topic subscriptions to receive replies.</p>
    <div class="Note">
      <p>Request-reply messaging can only be used with direct messages in the <MadCap:variable name="Product-Names.pubsub_brand_only"/> Go API.</p>
    </div>
    <p>To use the request-reply messaging pattern with the Go API, follow these steps:</p>
    <ol>
      <li>
        <MadCap:xref href="#Creating-A-RequestReplyMessagePublisher">Create a RequestReplyMessagePublisher</MadCap:xref>
      </li>
      <li>
        <MadCap:xref href="#Sending">Sending a Request</MadCap:xref>
      </li>
      <li>
        <MadCap:xref href="#Creating-A-RequestReplyMessageReceiver">Create a RequestReplyMessageReceiver</MadCap:xref>
      </li>
      <li>
        <MadCap:xref href="#Receivin3">Receiving Requests and Sending Replies</MadCap:xref>
      </li>
    </ol>
    <h2><a name="Creating-A-RequestReplyMessagePublisher"/>Create a RequestReplyMessagePublisher</h2>
    <p>To send message requests, create a <code>MessagingService</code> instance (see <MadCap:xref href="Go-API-Messaging-Service.htm#Messaging-Service">Messaging Service</MadCap:xref> for instructions). After you create a <code>MessagingService</code> instance and connect it to the event broker, use the <code>RequestReply()</code> function to build a <code>RequestReplyMessagePublisher</code> instance:</p>
    <pre xml:space="preserve">requestReplyPublisher, builderErr := messagingService.RequestReply().CreateRequestReplyMessagePublisherBuilder().Build()
if builderErr != nil {
    panic(builderErr)
}
			
startErr := requestReplyPublisher.Start()
if startErr != nil {
    panic(startErr)
}
</pre>
    <p>Next create an <code>OutboundMessage</code> instance. This is the request that your publisher sends to the receiver instance. For information on creating an <code>OutboundMessage</code> instance see <MadCap:xref href="Go-DM-Publish.htm#Configuring-Messages">Configuring and Creating Outbound Messages</MadCap:xref>. </p>
    <h2><a name="Sending"/>Sending a Request</h2>
    <p>When you send a request, it can be either synchronous or asynchronous. A synchronous request blocks your application until a reply is received. An asynchronous request allows your application to send multiple requests before any replies are received.</p>
    <ul>
      <li>
        <p>
          <MadCap:xref href="#Sending2">Sending a Synchronous Request</MadCap:xref>
        </p>
      </li>
      <li>
        <p>
          <MadCap:xref href="#Sending3">Sending an Asynchronous Request</MadCap:xref>
        </p>
      </li>
    </ul>
    <h3><a name="Sending2"/>Sending a Synchronous Request</h3>
    <p>The <MadCap:variable name="Product-Names.pubsub_brand_only"/> Go API provides synchronous request-reply messaging, which blocks each request until a reply is received. This is useful for synchronous, point to point communication where the order of events is important, for example when processing financial transactions. To send a synchronous request, use your <code>RequestReplyMessagePublisher</code> to call the <code>PublishAwaitResponse()</code> function. The <code>PublishAwaitResponse()</code> function takes the following parameters:</p>
    <ul>
      <li style="font-size: 11pt;"><code>requestMessage</code>—the <code>OutboundMessage</code> request to send</li>
      <li style="font-size: 11pt;"><code>requestDestination</code>—The <code>Topic</code> destination for request messages</li>
      <li style="font-size: 11pt;"><code>replyTimeout</code>—a <code>time.Duration</code> value representing the maximum time to wait for a response message</li>
      <li style="font-size: 11pt;"><code>properties</code>—(Optional) A <code>MessagePropertyMap</code> that contains additional message properties (see <MadCap:xref href="Go-DM-Publish.htm#Configuring-Messages">Configuring and Creating Outbound Messages</MadCap:xref>). Set this parameter to <code>nil</code> if you do not have additional message properties to set.</li>
    </ul>
    <p>For more information, see the <a href="../../API-Developer-Online-Ref-Documentation/go/index.html" class="link-internal"><a href="../../API-Developer-Online-Ref-Documentation/go/index.html" class="link-internal"><MadCap:variable name="Product-Names.pubsub_brand_only"/> Messaging API for Go reference</a></a>.</p>
    <p style="font-size: 11pt;">The following example shows how to send a message request synchronously and assign the reply to an <code>InboundMessage</code> instance:</p>
    <pre xml:space="preserve">
replyMsg, publishErr := requestReplyPublisher.PublishAwaitResponse(message, topic, 5*time.Second, nil)

if publishErr == nil { 
    fmt.Printf("The reply inbound payload: %s\n", replyMsg.GetPayloadAsString())
} else if terr, ok := publishErr.(*solace.TimeoutError); ok { 
    // No reply received, can implement resiliency or retry mechanisms here
    fmt.Printf("The reply timed out with %s with msg number : %d\n", terr, msgSeqNum)
} else { 
    panic(publishErr)
}		</pre>
    <p MadCap:conditions="Default.HideFromAllOutput">For a complete example, see @@@ on the <MadCap:variable name="Variables.CompanyName"/> Developer Hub.</p>
    <h3><a name="Sending3"/>Sending an Asynchronous Request</h3>
    <p>The <MadCap:variable name="Product-Names.pubsub_brand_only"/> Go API provides asynchronous request-reply messaging, which allows your application to send multiple requests before a reply is received. This is useful for asynchronous communication where the order of events is not important. To send an asynchronous request, use your <code>RequestReplyMessagePublisher</code> to call the <code>Publish()</code> function. The <code>Publish()</code> function takes the following parameters:</p>
    <ul>
      <li style="font-size: 11pt;"><code>requestMessage</code>—the <code>OutboundMessage</code> request to send</li>
      <li style="font-size: 11pt;"><code>replyMessageHandler</code>—an instance of <code>RequestReplyMessagePublisher.ReplyMessageHandler</code>, a callback handler to process the reply message when it arrives or when a timeout occurs.</li>
      <li style="font-size: 11pt;"><code>requestDestination</code>—the <code>Topic</code> destination for request messages</li>
      <li style="font-size: 11pt;"><code>replyTimeout</code>—a <code>time.Duration</code> value representing the maximum time to wait for a response message</li>
      <li style="font-size: 11pt;"><code>properties</code>—(Optional) A <code>MessagePropertyMap</code> that contains additional message properties (see <MadCap:xref href="Go-DM-Publish.htm#Configuring-Messages">Configuring and Creating Outbound Messages</MadCap:xref>). Set this parameter to <code>nil</code> if you do not have additional message properties to set.</li>
      <li style="font-size: 11pt;"><code>userContext</code>—(Optional) A <code>userContext</code> interface to be made available during response message processing (see <MadCap:xref href="Go-PM-Publish.htm#user-contexts">User Contexts</MadCap:xref>). Set this parameter to <code>nil</code> if you do not have context to set.</li>
    </ul>
    <p>For more information, see the <a href="../../API-Developer-Online-Ref-Documentation/go/index.html" class="link-internal"><a href="../../API-Developer-Online-Ref-Documentation/go/index.html" class="link-internal"><MadCap:variable name="Product-Names.pubsub_brand_only"/> Messaging API for Go reference</a></a>.</p>
    <p style="font-size: 11pt;">The following shows an example implementation of a <code>ReplyMessageHandler</code>, which sends a message request asynchronously and assigns the reply to an <code>InboundMessage</code> instance:</p>
    <pre xml:space="preserve">
func ReplyHandler(message message.InboundMessage, userContext interface{}, err error) {
	if err == nil { 
		fmt.Printf("The reply inbound payload: %s\n", message.GetPayloadAsString())
	} else if terr, ok := err.(*solace.TimeoutError); ok { 
		// No reply received, can implement resiliency or retry mechanisms here
		fmt.Printf("The reply timed out with %s with user context : %s\n", terr, userContext)
	} else { 
		panic(err)
	}
}			

// ...

publishErr := requestReplyPublisher.Publish(message, ReplyHandler, topic, 5*time.Second, nil, nil)
if publishErr != nil {
    panic(publishErr)
}</pre>
    <p MadCap:conditions="Default.HideFromAllOutput">For a complete example, see @@@ on the <MadCap:variable name="Variables.CompanyName"/> Developer Hub.</p>
    <h2><a name="Creating-A-RequestReplyMessageReceiver"/>Create a RequestReplyMessageReceiver</h2>
    <p>To send message replies, create a <code>MessagingService</code> instance (see <MadCap:xref href="Go-API-Messaging-Service.htm#Messaging-Service">Messaging Service</MadCap:xref> for instructions). After you create a <code>MessagingService</code> instance and connect it to the event broker, use the <code>RequestReply()</code> function to build a <code>RequestReplyMessageReceiver</code> instance:</p>
    <pre xml:space="preserve">requestReplyReceiver, builderErr := messagingService.RequestReply().CreateRequestReplyMessageReceiverBuilder().Build(topicSubscription)
if builderErr != nil {
    panic(builderErr)
}

startErr := requestReplyReceiver.Start()
if startErr != nil {
    panic(startErr)
}
</pre>
    <p>Next create an <code>OutboundMessage</code> instance. This is the reply that your receiver sends to the requestor instance. For information on creating an <code>OutboundMessage</code> instance see <MadCap:xref href="Go-DM-Publish.htm#Configuring-Messages">Configuring and Creating Outbound Messages</MadCap:xref>. </p>
    <h2><a name="Receivin3"/>Receiving Requests and Sending Replies</h2>
    <p>Your <code>RequestReplyMessageReceiver</code> can receive a request synchronously or asynchronously as an <code>InboundMessage</code> instance.</p>
    <ul>
      <li>
        <p>
          <MadCap:xref href="#Receivin">Receiving a Request Synchronously and Sending a Reply</MadCap:xref>
        </p>
      </li>
      <li>
        <p>
          <MadCap:xref href="#Receivin2">Receiving a Request Asynchronously and Sending a Reply</MadCap:xref>
        </p>
      </li>
    </ul>
    <h3><a name="Receivin"/>Receiving a Request Synchronously and Sending a Reply</h3>
    <p>The <MadCap:variable name="Product-Names.pubsub_brand_only"/> Go API provides synchronous request-reply messaging, which blocks your application until the <code>ReceiveMessage()</code> function returns. This is useful for synchronous, point to point communication where the order of events is important, for example when processing financial transactions. To receive a synchronous request, use your <code>RequestReplyMessageReceiver</code> instance to call the <code>ReceiveMessage()</code> function. The <code>ReceiveMessage()</code> function receives the request message <i>and</i> the replier instance from the <code>RequestReplyMessageReceiver</code>. The function takes the following parameter:</p>
    <ul>
      <li style="font-size: 11pt;"><code>Timeout</code>—a <code>time.Duration</code> value representing the time the function waits for a request message. The function waits forever if this value is negative.</li>
    </ul>
    <p>For more information, see the <a href="../../API-Developer-Online-Ref-Documentation/go/index.html" class="link-internal"><a href="../../API-Developer-Online-Ref-Documentation/go/index.html" class="link-internal"><MadCap:variable name="Product-Names.pubsub_brand_only"/> Messaging API for Go reference</a></a>.</p>
    <p style="font-size: 11pt;">The following shows an example implementation of a <code>RequestMessageHandler</code>, which receives a request message synchronously, assigns the reply to an <code>OutboundMessage</code> instance and sends it with the <code>Reply()</code> function:</p>
    <pre xml:space="preserve">
message, replier, receiveErr := requestReplyReceiver.ReceiveMessage(5 * time.Second)
if receiveErr != nil { receive pull was not successful
    if terr, ok := receiveErr.(*solace.TimeoutError); ok { // A timeout occurred and no request message was received
        // good location for implementing resiliency or retry mechanisms.
        fmt.Printf("request message pull from the receiver timed out with %s with last msg number : %d\n", terr, msgSeqNum)
        continue
    } else { 
        fmt.Println("Receiver error while trying to pull request message. Error: ", receiveErr)
    }
}

if replier != nil { // the replier is only set when received message is request message that can be replied to
    // build reply message
    replyMsg, replyMsgBuildErr := messageBuilder.BuildWithStringPayload(messageBody + "\nReply from: " + message.GetPayloadAsString())
    if replyMsgBuildErr != nil {
        panic(replyMsgBuildErr)
    }
    // send reply msg
    replyErr := replier.Reply(replyMsg)
    if replyErr != nil {
        fmt.Println("error on send reply. Error: ", replyErr)
    }
} else {
    // messages received on the topic subscription without a repliable destination will return a nil replier
    fmt.Printf("Received message: %d on topic %s that was not a request message\n", msgSeqNum, topicSubscription.GetName())
}
</pre>
    <p MadCap:conditions="Default.HideFromAllOutput">For a complete example, see @@@ on the <MadCap:variable name="Variables.CompanyName"/> Developer Hub.</p>
    <h3><a name="Receivin2"/>Receiving a Request Asynchronously and Sending a Reply</h3>
    <p>The <MadCap:variable name="Product-Names.pubsub_brand_only"/> Go API provides asynchronous request-reply messaging, which allows your application to receive multiple message requests asynchronously with the <code>ReceiveAsync()</code> function. This is useful for point to point communication where the order of events is not important. To receive asynchronous requests, use a <code>RequestReplyMessageReceiver</code> instance to call the <code>ReceiveAsync()</code> function. The <code>ReceiveAsync()</code> function takes the following parameter:</p>
    <ul>
      <li style="font-size: 11pt;"><code>requestMessageHandler</code>—an instance of <code>RequestReplyMessageReceiver.RequestMessageHandler</code>, a callback handler to process incoming request messages and the replier instances. This callback allows the <code>ReceiveAsync()</code> function to receive both an <code>inboundMessage</code> (the request) <i>and</i> an instance of <code>RequestReplyMessageReceiver.Replier</code>. The replier instance allows your <code>RequestReplyMessageReceiver</code> to send a reply back to the requestor.</li>
    </ul>
    <p>For more information, see the <a href="../../API-Developer-Online-Ref-Documentation/go/index.html" class="link-internal"><a href="../../API-Developer-Online-Ref-Documentation/go/index.html" class="link-internal"><MadCap:variable name="Product-Names.pubsub_brand_only"/> Messaging API for Go reference</a></a>.</p>
    <p style="font-size: 11pt;">The following shows an example implementation of a <code>RequestMessageHandler</code>, which receives a request message asynchronously, assigns the reply to an <code>OutboundMessage</code> instance and sends it with the <code>Reply()</code> function:</p>
    <pre xml:space="preserve">
requestMessageHandler := func(message message.InboundMessage, replier solace.Replier) {

    if replier == nil { // the replier is only set when received message is a request message that can be replied to
        // messages received on the topic subscription without a reply destination will return a nil replier
        fmt.Printf("Received message: %d on topic %s that was not a request message\n", msgSeqNum, topicSubscription.GetName())
        return
    }
    replyMsg, replyMsgBuildErr := messageBuilder.BuildWithStringPayload(messageBody + "\nReply from: " + message.GetPayloadAsString())
    if replyMsgBuildErr != nil {
        panic(replyMsgBuildErr)
    }
    replyErr := replier.Reply(replyMsg)
    if replyErr != nil {
        fmt.Println("Error on send reply: ", replyErr)
    }
}

requestReplyReceiver.ReceiveAsync(requestMessageHandler)	</pre>
    <p MadCap:conditions="Default.HideFromAllOutput">For a complete example, see @@@ on the <MadCap:variable name="Variables.CompanyName"/> Developer Hub.</p>
  </body>
</html>
