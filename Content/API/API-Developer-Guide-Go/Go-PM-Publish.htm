<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
  <head>
    </head>
  <body>
    <h1><a name="Publishing-Persistent-Messages-Java-API"/>Publishing Persistent Messages Using the Go API</h1>
    <p>When your applications require confirmation handling and <i>exactly once</i> delivery, we recommend that you use persistent messages instead of  direct messages. To publish persistent messages in the <MadCap:variable name="Product-Names.pubsub_brand_only"/> Go API,  you first set up a message queue on the <MadCap:variable name="Product-Names.pubsub_brand_only"/> event broker. </p>
    <p> For information about creating and configuring queues on an event broker, see <MadCap:xref href="../../Messaging/Guaranteed-Msg/Configuring-Queues.htm">Configuring Queues</MadCap:xref>. </p>
    <p>To  handle persistent messages using the <MadCap:variable name="Product-Names.pubsub_brand_only"/> Go API, use the following steps:</p>
    <ol>
      <li><a href="#Creating-A-PersistentMessagePublisher-Object" class="link-internal">Create a PersistentMessagePublisher</a>.</li>
      <li><a href="#Configuring-Messages" class="link-internal">Configure and Create an OutboundMessage</a>.</li>
      <li><a href="#Configuring-Back-Pressure" class="link-internal">Handling Back-Pressure When Publishing Persistent Messages</a>.</li>
      <li><a href="#Publishing-A-Persistent-Message" class="link-internal">Publish a Persistent Message</a>.</li>
      <li><a href="#Message-Receipts-and-Error-Handling" class="link-internal">Acknowledging Messages and Handling Errors</a>.</li>
      <li><a href="#user-contexts" class="link-internal">User Contexts</a>.</li>
    </ol>
    <p>In some use cases, it's possible for your application to send messages faster than the messages can be transported. This may cause messages to accumulate in the API internal buffers causing back-pressure. If this scenario is possible, consider changing the back-pressure settings to meet the requirements of your application. For more information, see <MadCap:xref href="#Configuring-Back-Pressure">Configuring Back-pressure</MadCap:xref>.</p>
    <p>For examples of applications  that publish persistent messages, see <a href="https://github.com/SolaceSamples/solace-samples-go/blob/main/patterns/guaranteed_publisher.go" class="link-offsite">guaranteed_publisher.go</a> on the <MadCap:variable name="Variables.CompanyName"/> GitHub page.</p>
    <h2 class="with-rule"><a name="Creating-A-PersistentMessagePublisher-Object"/>Creating a PersistentMessagePublisher</h2>
    <p>After a <code>MessagingService</code> instance has established a connection to an event broker, you  use a <code>PersistentMessagePublisher</code>  to publish persistent messages. You can use a <code>PersistentMessagePublisherBuilder</code> to configure your <code>PersistentMessagePublisher</code> to use certain features of the API, such as back-pressure strategies. Call the <code>Build()</code> function on your <code>PersistentMessagePublisherBuilder</code> to return a <code>PersistentMessagePublisher</code>instance. To enable your <code>PersistentMessagePublisher</code> to start publishing messages, call <code>Start()</code> on it.</p>
    <p>The following shows an example of how to use <code>PersistentMessagePublisher</code> to connect to the event broker using a <code>MessagingService</code> instance:</p>
    <pre xml:space="preserve">/* Creates an instance of PersistentMessagePublisherBuilder, which is used to create PersistentMessagePublishers. */
persistentPublisher, builderError := messagingService. 
	CreatePersistentMessagePublisherBuilder(). // Creates a PersistentMessagePublisherBuilder that can be used to configure persistent message publisher instances.
	Build()                                    // Creates a new PersistentMessagePublisher instance based on the configured properties.
if builderErr != nil {
	panic(builderErr)
}

startErr := persistentPublisher.Start()    // Start starts the publisher synchronously. Before this function is called, the publisher is considered off-duty.
if startErr != nil {
	panic(startErr)
}  
</pre>
    <h3>Asynchronous Publishers</h3>
    <p>It is also possible to start a persistent message publisher using a callback listener to allow for asynchronous notifications after the start operation is complete.</p>
    <p>The following example shows how to start a <code>PersistentMessagePublisher</code> asynchronously:</p>
    <pre xml:space="preserve">
func PublisherCallback(publisher solace.PersistentMessagePublisher, err error) {
	if err != nil {
		panic(err) // Publisher started up with an error.
	} else {
		// Publisher started without issue.
	}
}
// ...	
// ...
persistentPublisher.StartAsyncCallback(PublisherCallback) // Starts the publisher asynchronously. Calls the callback when started with an error if one occurred, otherwise nil if successful.</pre>
    <p class="Note">Your publisher application is not operational until you call <code>Start()</code> or <code>StartAsyncCallback()</code> on it.</p>
    <h2 class="with-rule"><a name="Configuring-Messages"/>Configuring and Creating Outbound Messages</h2>
    <p>Your client applications explicitly create the outbound messages to publish. In the <MadCap:variable name="Product-Names.pubsub_brand_only"/> Go API, when you publish messages you use <code>OutboundMessage</code> instances. To configure and create <code>OutboundMessage</code> instances, follow these steps: </p>
    <ol>
      <li>
        <p>Call  <code>messagingService.MessageBuilder()</code> to return an <code>OutboundMessageBuilder</code> instance. For better performance, we recommend you use a single <code>OutboundMessageBuilder</code> to create multiple <code>OutboundMessage</code> instances. </p>
        <pre xml:space="preserve">messageBuilder := messagingService.MessageBuilder()</pre>
      </li>
      <li>Configure your message with an <code>OutboundMessageBuilder</code> and then call the <code>Build()</code> function to return a message instance. You can configure message properties using either method below.
			
				<ul><li>Use <code>config.MessagePropertyMap</code> and the <code>config.MessageProperty*</code> functions. The following example shows how to set <code>MessagePropertyMap</code>  values for message ID, sender ID and message type constants, and then configure a message using the <code>FromConfigurationProvider()</code> function:		<pre xml:space="preserve">
messageProperties := config.MessagePropertyMap{
	config.MessagePropertyApplicationMessageID: "message ID",
	config.MessagePropertySenderID:      "Sender ID",
	config.MessagePropertyApplicationMessageType: "Message Type",
	// For a complete list of MessageProperty constants see the <a href="../../API-Developer-Online-Ref-Documentation/go/index.html" class="link-internal"><MadCap:variable name="Product-Names.pubsub_brand_only"/> Messaging API for Go reference</a>.
}	
// ...						
// ...						
message, err := messageBuilder.FromConfigurationProvider(messageProperties)
	.BuildWithStringPayload("my message payload")
if err != nil {
	panic(err)
}</pre></li><li>Use the <code>OutboundMessageBuilder</code> interface and the <code>WithProperty(propertyName,propertyValue)</code> functions. Both Solace defined <code>config.MessageProperty</code> keys as well as arbitrary user-defined property keys are accepted. The following example shows how to set a custom key-value property on a message:<pre xml:space="preserve">
messageBuilder := messagingService.MessageBuilder().
	WithProperty("propertyName", "propertyValue")
// ...							
// ...							
message, err := messageBuilder.BuildWithStringPayload("my message payload")
if err != nil {
	panic(err)
}</pre></li></ul></li>
    </ol>
    <p>The following code example shows how to create a message builder, set message properties and create a message:</p>
    <pre xml:space="preserve">
/* Builder for creation of similarly configured messages */
messageBuilder := messagingService.MessageBuilder()
message, err := messageBuilder.
	FromConfigurationProvider(messageProperties).     // For Sender ID, Sequence Number etc.  
	WithExpiration(time.Now().Add(10 * time.Second)). // Expire the message in 10 seconds.
	BuildWithStringPayload("my message payload")      // Builds the message.</pre>
    <p>For more information about the functions, see the <a href="../../API-Developer-Online-Ref-Documentation/go/index.html" class="link-internal"><a href="../../API-Developer-Online-Ref-Documentation/go/index.html" class="link-internal"><MadCap:variable name="Product-Names.pubsub_brand_only"/> Messaging API for Go reference</a></a>.</p>
    <h3><a name="Setting"/>Setting a Partition Key</h3>
    <p>You can set a partition key to use partitioned queues. Partitioned Queues is a feature configured on the <MadCap:variable name="Product-Names.pubsub_brand_only"/> Event Broker that allows you to easily scale the number of consumer applications bound to a queue. A partition key can be set on each message in the publishing application to ensure that all messages with the same partition key are delivered to the same consumer without additional logic in the consumer application. For more information see <MadCap:xref href="../../Messaging/Guaranteed-Msg/Queues.htm#partitioned-queues">Partitioned Queues</MadCap:xref>.</p>
    <p>Use the <code>WithProperty(property,value)</code> function to set a property-value pair on a Go API message.</p>
    <ul>
      <li>
        <p><code>property</code>—The constant <code>config.QueuePartitionKey</code> or the string value <code>JMSXGroupID</code>.</p>
      </li>
      <li>
        <p><code>value</code>—A string representing the value of your partition key. Client applications set the value at publish time. </p>
      </li>
    </ul>
    <p>The following example shows how to set the value of the constant <code>config.QueuePartitionKey</code>:</p>
    <pre xml:space="preserve">
// Set the queue partition key on the outbound message using the `with_property()` builder method.
func SetQueuePartitionKeyUsingWithProperty(queuePartitionKeyValue string) {
    payload = "my_payload"
 
    outboundMessage = messaging
        .MessagingService
        .MessageBuilder()
        .WithProperty(config.QueuePartitionKey, queuePartitionKeyValue)
        .BuildWithStringPayload(payload)
}
 
// You can also set the queue partition key on the outbound message using the `from_properties()` builder method.
func SetQueuePartitionKeyUsingFromConfigurationProvider(queuePartitionKeyValue string) {
    payload = "my_payload"
    messageConfig := config.MessagePropertyMap{
        config.QueuePartitionKey: queuePartitionKeyValue,
    }
 
    outboundMessage = messaging
        .MessagingService
        .MessageBuilder()
        .FromConfigurationProvider(messageConfig)
        .Build(payload)
}
</pre>
    <h2 class="with-rule"><a name="Configuring-Back-Pressure"/>Handling Back-Pressure When Publishing Persistent Messages</h2>
    <MadCap:snippetBlock src="../../Resources/Snippets/API-Guide/NG-API/backpressureintro-publisher-persistent-messages.flsnp"/>
    <p> In the <MadCap:variable name="Product-Names.pubsub_brand_only"/> Go API, the <code>PersistentMessagePublisherBuilder</code> has two primary  mechanisms to handle back-pressure which you can use:</p>
    <ul>
      <li>
        <a href="#reject" class="link-internal">reject messages when a specified limit is reached</a>
      </li>
      <li>
        <a href="#throttle" class="link-internal">throttle the publisher  when a specified limit is reached</a>
      </li>
    </ul>
    <h3><a name="reject"/>Rejecting Messages When a Specified Limit is Reached </h3>
    <p>When back-pressure occurs, you can choose to reject the messages from the client application when a specified limit is reached in the internal buffer. You can use  <code>OnBackPressureReject(bufferSize uint)</code> function to specify a defined buffer capacity for a set number of messages to accumulate. After the specified capacity is reached, it is no longer possible to publish new messages and errors are returned until the buffer has capacity again. On calls to publish,  <code>bufferSize</code> must be greater than or equal to zero. </p>
    <pre xml:space="preserve">/* Creates an instance of PersistentMessagePublisherBuilder, which is used to create PersistentMessagePublishers. */
persistentPublisher, builderError := messagingService. 
	CreatePersistentMessagePublisherBuilder(). // Creates a PersistentMessagePublisherBuilder that can be used to configure persistent message publisher instances.
	OnBackPressureReject(500).                 // Sets the pressure strategy to reject messages once the bufferSize, in number of messages, is reached.
	Build()                                    // Creates a new PersistentMessagePublisher instance based on the configured properties.
if builderErr != nil {
	panic(builderErr)
}

startErr := persistentPublisher.Start()    // Start starts the publisher synchronously. Before this function is called, the publisher is considered off-duty.
if startErr != nil {
	panic(startErr)
}     </pre>
    <h4><a name="publisher-readiness-listener"/>Using a Publisher Readiness Listener</h4>
    <p>We recommend that you use a <code>PublisherReadinessListener</code> when you use the <code>OnBackPressureReject()</code> function because it lets your application know when there is capacity available in the buffer and it can resume publishing messages. </p>
    <p>The following is an example of registering an event handler using a <code>PublisherReadinessListener</code>: </p>
    <pre xml:space="preserve">
func PublisherReadinessListener(){
	// What you want your application to do when it can publish messages again.
}
// ...
// ...
persistentPublisher, builderError := messagingService. 
CreatePersistentMessagePublisherBuilder(). // Creates a PersistentMessagePublisherBuilder that can be used to configure persistent message publisher instances.
OnBackPressureReject(500).	       // Sets the pressure strategy to reject messages once the bufferSize, in number of messages, is reached.
Build()                                // Creates a new PersistentMessagePublisher instance based on the configured properties.
if builderErr != nil {
	panic(builderErr)
}

startErr := persistentPublisher.Start()    // Start starts the publisher synchronously. Before this function is called, the publisher is considered off-duty.
if startErr != nil {
	panic(startErr)
}
persistentPublisher.SetPublisherReadinessListener(canPublishListener);    // Registers a listener to be called when the publisher can send messages.     </pre>
    <p class="Note"> For the best performance, we recommend you use <code>OnBackPressureReject(0)</code> with a<code> PublisherReadinessListener</code>.  A <code>bufferSize</code> of zero means the publisher application will not buffer messages before sending them to the broker, which reduces latency and improves performance. This prevents large numbers of messages accumulating on the publisher's internal buffer and is the most performant method of dealing with back pressure. </p>
    <h3><a name="throttle"/>Throttling Publisher When a Specified Limit is Reached</h3>
    <p>You can choose to throttle the publishing application if a specified limit is reached in the internal buffer. The use of throttling is useful to free capacity to its internal buffers. You can use the  <code>OnBackPressureWait(bufferSize uint)</code> function to set the maximum number of messages that can accumulate in the buffer. The default setting for the <MadCap:variable name="Product-Names.pubsub_brand_only"/> Go API is for the publisher application to wait with a <code>bufferSize</code> of 50. When this maximum capacity (<code>bufferSize</code>) is reached, the publisher routine pauses and waits for  available capacity in the internal buffer before letting the application publish any more messages.</p>
    <p> This function should be used when you want the publishing application to wait for space when the buffer's capacity has been reached. Using this mechanism gives time for the API to empty the internal buffer. An additional benefit for persistent messaging with this configuration is that the API does not discard any messages. </p>
    <p>The following shows an example of how to configure the internal buffer to accommodate up to one thousand messages:</p>
    <pre xml:space="preserve">
persistentPublisher, builderError := messagingService. 
	CreatePersistentMessagePublisherBuilder(). // Creates a PersistentMessagePublisherBuilder that can be used to configure persistent message publisher instances.
	OnBackPressureWait(1000).                   // Sets back pressure strategy to wait and block until there is space in the buffer of size bufferSize.
	Build()                                    // Creates a new PersistentMessagePublisher instance based on the configured properties.
if builderErr != nil {
	panic(builderErr)
}

startErr := persistentPublisher.Start()    // Start starts the publisher synchronously. Before this function is called, the publisher is considered off-duty.
if startErr != nil {
	panic(startErr)
}  </pre>
    <h2 class="with-rule"><a name="Publishing-A-Persistent-Message"/>Publishing a Persistent Message</h2>
    <p>After you have established a connection to the event broker using a <code>MessagingService</code>instance, you can use a <code>PersistentMessagePublisher</code> to publish persistent messages.</p>
    <p> A persistent message has the following components: </p>
    <ul>
      <li>A topic to publish to (required) </li>
      <li>A message payload (optional) </li>
    </ul>
    <p>Persistent message publishing involves the receipt of acknowledgments or <i>publish receipts</i>. Depending on your requirements, your client application can publish as:</p>
    <ul>
      <li>   non-blocking, allows your application to perform other functions while the <code>PublishReceiptListener</code> waits for the acknowledgment</li>
      <li>blocking,  waits until an acknowledgment has been received; an acknowledge indicates that the message has been received and persisted by the broker</li>
    </ul>
    <h3><a name="non-block-methods"/>Non-Blocking Functions </h3>
    <p>The following are non-blocking functions:</p>
    <ul>
      <li>
        <code>PublishBytes(message []byte, destination *resource.Topic)</code>
      </li>
      <li>
        <code>PublishString(message string, destination *resource.Topic)</code>
      </li>
      <li>
        <code>Publish(message message.OutboundMessage, destination *resource.Topic, properties config.MessagePropertiesConfigurationProvider, context interface{})</code>
      </li>
    </ul>
    <p>For more information about these functions, see the <a href="../../API-Developer-Online-Ref-Documentation/go/index.html" class="link-internal"><MadCap:variable name="Product-Names.pubsub_brand_only"/> Messaging API Go reference</a>.</p>
    <h3><a name="block-methods"/>Blocking Functions</h3>
    <p>If you want your publisher to await for an acknowledgment from the broker before returning from the <code>Publish()</code> call, you can use the following blocking function:</p>
    <ul>
      <li>
        <code>PublishAwaitAcknowledgement(message message.OutboundMessage, destination *resource.Topic, timeout time.Duration, properties config.MessagePropertiesConfigurationProvider)</code>
      </li>
    </ul>
    <p>The preceding function can be used with a <code>PersistentMessagePublisher</code> to publish an <code>OutboundMessage</code> to the broker using a topic. This function blocks the main routine until either:</p>
    <ul>
      <li>the publisher API receives an acknowledgment from the broker </li>
      <li> the timeout period elapses</li>
    </ul>
    <pre xml:space="preserve">messageBody := "Hello from Go Persistent Publisher Sample"
messageBuilder := messagingService.MessageBuilder().     // Creates an OutboundMessageBuilder that can be used to build messages.
WithProperty("application", "samples").                  // Sets an individual message property on the resulting message.
WithProperty("language", "go")				  // Both Solace defined config.MessageProperty keys as well as user-defined property keys are accepted.

go func() {
	for persistentPublisher.IsReady() {                   // Checks if the publisher can publish messages.
	message, err := messageBuilder.BuildWithStringPayload(messageBody)
		if err != nil {
			panic(err)
		}

		topic := resource.TopicOf("go/persistent/publisher/")

		publishErr := persistentPublisher.PublishAwaitAcknowledgement(message, topic, 2*time.Second, nil) // Sends the message and awaits an acknowledgement. on OutboundMessage
		if publishErr != nil {										  // Optionally, you can provide properties in the form of OutboundMessageProperties to override  
			panic(publishErr)									  // any properties set on OutboundMessage	
		}
	}
}()              </pre>
    <h2 class="with-rule"><a name="Message-Receipts-and-Error-Handling"/>Acknowledging Messages and Handling Errors</h2>
    <p>A publish receipt is a delivery confirmation that indicates whether or not the event broker successfully processed the message. These publish receipts can indicate success or failure, and are handled by a <code>MessagePublisReceiptListener</code> instance. You can set your <code>MessagePublishReceiptListener</code> with the <code>SetMessagePublishReceiptListener()</code> function. </p>
    <p>The following example shows how to use the  <code>MessagePublishReceiptListener</code> to listen for publish receipts:</p>
    <pre xml:space="preserve">
/* listener that processes all delivery confirmations/timeouts for all messages */
func PublishReceiptListener(receipt solace.PublishReceipt) {
	fmt.Println("Received a Publish Receipt from the broker\n")
	fmt.Println("IsPersisted: ", receipt.IsPersisted())
	fmt.Println("Message : ", receipt.GetMessage())
	if receipt.GetError() != nil {
		fmt.Println("Gauranteed Message is NOT persisted on the broker! Received NAK")
		fmt.Println("Error is: ", receipt.GetError())
		// probably want to do something here.  some error handling possibilities:
		//  - send the message again
		//  - send it somewhere else (error handling queue?)
		//  - log and continue
		//  - pause and retry (backoff) - maybe set a flag to slow down the publisher
	}
}

persistentPublisher.SetMessagePublishReceiptListener(PublishReceiptListener)           // Listen to all delivery confirmations for all messages being sent.
publishErr := persistentPublisher.PublishString("Hello world!", topicDestination)      // Publish a message with a String payload.	
if publishErr != nil {										  
	panic(publishErr)									  	
}     </pre>
    <h3><a name="strategies"/>Strategies for Handling Publish Receipt Errors</h3>
    <p>The following are application-specific strategies you can use to handle receipt errors when publishing. </p>
    <dl>
      <dt>Wait and Retry</dt>
      <dd>Wait a number of seconds before trying to send the message again. For example, using <code>time.sleep(1000)</code> to wait for 1 second before attempting to publish again.</dd>
      <dt>Retry a Predefined number of Times</dt>
      <dd>      Try to re-publish the message a predefined number of times before dropping it.</dd>
      <dt>Discard the Message</dt>
      <dd>Simply discard messages with failed publish receipts. We don't recommend this strategy if your application cannot tolerate message loss. </dd>
    </dl>
    <p class="Note"> To receive a failed publish receipt when there is no matching subscription, this option must be set for the event broker or <MadCap:variable name="Product-Names.broker_cloud_short"/>. For more information, see <MadCap:xref href="../../Security/Configuring-Client-Profiles.htm#Configur">Handling Guaranteed Messages with No Matches</MadCap:xref> (for <MadCap:variable name="Product-Names.broker_appliance_short"/>s and <MadCap:variable name="Product-Names.broker_sw_short"/>s) or the <b><a href="../../Cloud/client-profiles.htm#configuring-client-profile-settings" class="link-internal">Reject Messages to Sender On No Subscription Match Discard</a></b> (for <MadCap:variable name="Product-Names.cloud_product_short"/>).</p>
    <h2><a name="user-contexts"/>User Contexts</h2>
    <p>Optionally, you can use <i>user contexts</i> to correlate information for persistent messages to publish receipts in your application. This information is user-specific and is meaningful only to your publishing application and is not sent to the broker.  A user context permits you to attach data to the publish call that can later be retrieved from the publish receipt listener.</p>
    <p>When you use a user context, it allows you to handle multiple scenarios.   It also allows your application to decide what action to take or how to process the publish receipt based on the context. </p>
    <p>For example, if a non-blocking application has multiple routines to publish persistent messages, each routine can include its identifier as the user context when it publishes a persistent message. The <MadCap:variable name="Product-Names.pubsub_brand_only"/> Go API tracks the user context when specified for each message and returns the user context as part of the publish receipt when the message is acknowledged or rejected by the event broker. The publishing application can then send the publish receipt to the correct routine that sent the message based on the user context.</p>
    <p>You can set the user context when you publish the message. For example, you use the <code>Publish(message message.OutboundMessage, destination *resource.Topic, properties config.MessagePropertiesConfigurationProvider, context interface{})</code> function, where the user context is specified as type <code>interface{}</code>.</p>
    <p>The following example shows how to get the user context from a publish receipt:</p>
    <pre xml:space="preserve">/* A simple example of a persistent message publishReceipt */
var acknowledgedMessage message.OutboundMessage = publishReceipt.GetMessage() // Retrieves message associated with a Receipt.    
userContext := publishReceipt.GetUserContext()        // Corresponding context can be retrieved this way from a publish receipt when provided during message publishing.
</pre>
    <p>If your application is non-blocking, you can also use a persistent message publisher with publish receipt in your callback to log information. For example, you can use non-blocking message publishing and then  send alerts to notify the application of the status of published messages, such as:</p>
    <ul>
      <li> the event broker successfully receives and processes a message</li>
      <li>access control violations (ACL)</li>
      <li> a queue being over quota</li>
      <li> invalid topics / topics with no subscribers</li>
    </ul>
    <p> The following code shows an example of a <code>PublishReceiptListener</code>:</p>
    <pre xml:space="preserve">/* listener that processes all delivery confirmations/timeouts for all messages */
func PublishReceiptListener(receipt solace.PublishReceipt) {
	fmt.Println("Received a Publish Receipt from the broker\n")
	fmt.Println("IsPersisted: ", receipt.IsPersisted())
	fmt.Println("Message : ", receipt.GetMessage())
	if receipt.GetError() != nil {
		fmt.Println("Gauranteed Message is NOT persisted on the broker! Received NAK")
		fmt.Println("Error is: ", receipt.GetError())
		// probably want to do something here.  some error handling possibilities:
		//  - send the message again
		//  - send it somewhere else (error handling queue?)
		//  - log and continue
		//  - pause and retry (backoff) - maybe set a flag to slow down the publisher
	}
}
persistentPublisher.SetMessagePublishReceiptListener(PublishReceiptListener)     // Listen to all delivery confirmations for all messages being sent.
publishErr := persistentPublisher.PublishString("Hello world!", topicDestination)      // Publish a message with a String payload.	
if publishErr != nil {										  
	panic(publishErr)									  	
}</pre>
  </body>
</html>
