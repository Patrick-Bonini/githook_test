<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
  <head>
    </head>
  <body>
    <h1><MadCap:concept term="Cloud;Appliance;Software"/>Guaranteed Messages</h1>
    <p>Guaranteed messaging can ensure the delivery of  messages between applications, even in cases where the receiving application is offline or there is a failure of a piece of network equipment. Messages are delivered in the order they were published.</p>
    <p>Guaranteed messaging keeps messages across event broker restarts by spooling them to persistent storage. The event broker keeps a copy of the message until successful delivery to all clients and downstream event brokers has been verified</p>
    <p>Although a persistent delivery mode is typically used for Guaranteed messages, a non-persistent delivery mode is provided to offer compatibility with Java Message Service (JMS), and to allow the delivery mode of the messages to be modified to accommodate the persistence requirements of an endpoint or a client subscription when there is a topic match.  For more information, see <MadCap:xref href="Topic-Matching-and-Delivery-Modes.htm">Topic Matching and Message Delivery Modes</MadCap:xref>.</p>
    <p MadCap:conditions="SAP.SapHideFromOutput">To support Guaranteed messaging, event brokers must have message spooling enabled. In addition,  <MadCap:variable name="Product-Names.pubsub_brand_only"/> <MadCap:variable name="Product-Names.broker_appliance_short"/>s must also have an Assured Delivery Blade (ADB) installed. Message spooling is enabled by default on <MadCap:variable name="Product-Names.cloud_product_firstuse"/> <MadCap:variable name="Product-Names.broker_cloud_short"/>s.</p>
    <p>Messages accepted by the event broker through Guaranteed messaging for delivery to clients are never lost, but might not be accepted if system resource limits are exceeded. If an ingress message can't be received by the event broker (for example, if the spool quota is exceeded), the publisher is not acknowledged, and the appropriate event broker statistic is incremented.</p>
    <h2 class="with-rule"><a name="Use_Cases"/>Guaranteed Messaging Use Cases</h2>
    <p>This section provides examples of scenarios where Guaranteed messaging is commonly used:</p>
    <ul>
      <li>
        <MadCap:xref href="#message_request_queues">Message Request Queues</MadCap:xref>
      </li>
      <li>
        <MadCap:xref href="#Slow_Consumers">Slow Consumers</MadCap:xref>
      </li>
      <li>
        <MadCap:xref href="#request_reply">Request/Reply with Guaranteed Messages</MadCap:xref>
      </li>
    </ul>
    <h3><a name="message_request_queues"/>Message Request Queues</h3>
    <p>If a queue is created with non-exclusive access mode, consumers can load balance the processing of the message requests. Alternatively, the queue can be made exclusive so that only the first consumer will process requests and the other customers that bind act as backup should the first consumer disconnect. The publishing client is decoupled from knowing how the message items are processed—they simply publish request messages to the queue.</p>
    <p>The consumers can also configure their maximum window sizes and maximum unacked messages to set how many message items are pipelined to them in their flows. As each message item is processed, the consumer application triggers an acknowledgment back to the event broker to pull another message into its flow pipeline.</p>
    <p>If you need to ensure that messages persist even if all consumers disconnect from the queue, use a durable queue instead of one that's temporary.</p>
    <p>It you need to constrain access to the message queue to control which applications can subscribe to the request messages, set a specific user (for example, client user name <code>messageItemProcessor</code>) as the owner of the queue, and set the <code>others</code> permission to <code>none</code>.</p>
    <h3><a name="Slow_Consumers"/>Slow Consumers</h3>
    <p>Guaranteed messaging can be used to buffer messages for slow consumers. For example, a client application that uses a topic subscription to receive Direct messages and then writes them to a database may not be able to keep up with a large burst of messages from a publisher. </p>
    <p>To handle such a scenario, the client could create a durable queue and add a topic subscription to it. The topic subscription would attract the messages, which would be changed to non-persistent and spooled to the queue. The client application can then consume and acknowledge without worrying about message rates that overwhelm its processing capabilities. The publisher is also able to publish as quickly as possible and does not need to account for potential slow consuming applications.</p>
    <h3><a name="request_reply"/>Request/Reply with Guaranteed Messages</h3>
    <p>From a high-level point-of-view, the following steps occur:</p>
    <ol>
      <li>The event broker is provisioned to support Guaranteed messaging.</li>
      <li>The customer application uses a client to create a non-durable queue on the event broker, and then creates a consumer flow to bind to that queue.</li>
      <li>The client publishes a (possibly Guaranteed) message with the request to a well-known topic, specifying that the reply to the request be sent to the newly created temporary queue.</li>
      <li>The event broker listens to the topic (or binds to the queue if it has a topic subscription added to it) and responds to the request by publishing to the specified non‑durable queue.</li>
      <li>The client consumes the reply message from the non-durable queue. Once it has finished processing the responses, it closes the flow, which deletes the non-durable queue.</li>
    </ol>
    <p> </p>
  </body>
</html>
