<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" MadCap:searchable="False" MadCap:conditions="Default.NotForPDF">
  <head>
    <link href="../../Resources/TableStyles/Table_Num.css" rel="stylesheet" MadCap:stylesheetType="table"/>
    <meta name="robots" content="noindex, nofollow"/>
  </head>
  <body>
    <h1><MadCap:concept term="Cloud"/><MadCap:conditionalText MadCap:conditions="SAP.SapHideFromOutput"><MadCap:variable name="Product-Names.pubsub_brand_only"/></MadCap:conditionalText><MadCap:variable name="Product-Names.eventportal_product_short"/> 1.0</h1>
    <p><MadCap:variable name="Product-Names.eventportal_product_long"/> is an event management tool—presented through an accessible Web user interface (UI)—that enables you to design, discover, visualize, share, and manage various aspects of your event-driven architecture (EDA). </p>
    <p>A key benefit of using  <MadCap:variable name="Product-Names.eventportal_product_short"/> is its ability to track the relationships that exist in an extremely decoupled event-driven architecture (EDA). It enables the reuse of schemas and events, and graphically presents the relationships that exist between applications and events. <MadCap:conditionalText MadCap:conditions="Default.HideFromAllOutput">For example, a schema may be used by many different events, and the business object changes through a transaction. Multiple producers may produce an event, and an application may consume and/or produce many events. Finally, events may be shared across various application domains. Thus, the <MadCap:variable name="Product-Names.eventportal_product_short"/> helps you manage and understand the EDA regardless of which event broker is being used at runtime.</MadCap:conditionalText></p>
    <p>Furthermore, as an <MadCap:variable name="Product-Names.eventportal_product_short"/> user, you can model your event-driven architecture (EDA) in different operational environments. <MadCap:variable name="Product-Names.eventportal_product_short"/> allows for environment separation, in the same way how the event broker services are separated within enterprises. This means you can create a different cloud console or <MadCap:variable name="Product-Names.eventportal_product_short"/> account for each environment within enterprise. You can then create and grant different user access permissions for each of these environments, and use that to model your EDAs as they progress from one environment to the next.</p>
    <p>
      <MadCap:conditionalText MadCap:conditions="Default.HideFromAllOutput">EDAs, including all associated applications, events, and payload schemas, can be promoted from one environment to the next by exporting entire Application Domains from the previous environment and importing it into the next, using the Import/Export Application Domain functionality in <MadCap:variable name="Product-Names.eventportal_product_short"/>.</MadCap:conditionalText>
    </p>
    <p>To get started, let's first understand the <MadCap:xref href="#Foundati">Foundational Elements of the [%=Product-Names.eventportal_product_short%]</MadCap:xref>.</p>
    <h2 class="with-rule"><a name="Foundati"/>Foundational Elements of <MadCap:variable name="Product-Names.eventportal_product_short"/></h2>
    <p>When designing an event-driven architecture (EDA), it is essential to model the enterprise or interworking systems as a whole, which means dividing it into smaller, more manageable pieces. Once broken down into what the <MadCap:variable name="Product-Names.eventportal_product_short"/> defines as an Application Domain, within each application domain, you can create a set of event-driven entities or objects (schemas, events and applications) which represent the runtime interactions.</p>
    <p>The following are the four foundational elements of the <MadCap:variable name="Product-Names.eventportal_product_short"/>:</p>
    <ul>
      <li>
        <MadCap:xref href="#Applicat">Application Domain</MadCap:xref>
      </li>
      <li>
        <MadCap:xref href="#Schema">Schema</MadCap:xref>
      </li>
      <li>
        <MadCap:xref href="#Event5">Event</MadCap:xref>
      </li>
      <li>
        <MadCap:xref href="#Applicat2">Application</MadCap:xref>
      </li>
    </ul>
    <p>Schemas, Events, and Applications are often referred to as objects in <MadCap:variable name="Product-Names.eventportal_product_short"/>.</p>
    <h3><a name="Applicat"/>Application Domain</h3>
    <p>An application domain represents a namespace where applications, events, and schemas can live. Application domains are useful to decompose the enterprise and create organizational boundaries within which teams can work. Within the application domain, you can create a suite of applications, events and schemas that are isolated from other application domains. This provides a way to create independent event-driven architectures for different products. You can also <a href="#Shared" class="link-internal">share events and schemas</a> across application domains enabling the integration of events and data between different organizational groups, in a controlled and governed manner. The use of one or more application domains provides a way to organize and create event-driven architectures for different teams, groups or lines of business within the organization. Organizations should determine the best use of application domains based on their organizational structure and architectural goals.</p>
    <p>An application, event and schema can only belong to one application domain for organizational ownership reasons. An event and schema can be marked as “shared” to enable their use across application domain boundaries. This enables the users of the application domain to more strictly govern those events that are exposed externally to their application domain while maintaining agility in terms of the ability to make changes to those events which are contained within the application domain.</p>
    <p>Furthermore, application domains define a topic domain. For all the events in the application domain, the topics defined for these events should be named with the topic domain at the beginning of the topic address. For example, if a topic domain is defined as <code>solace/weather</code>, then an event in that application domain may be named <code>solace/weather/blizzard/started</code>.</p>
    <h3><a name="Schema"/>Schema</h3>
    <p>In simple terms, a schema represents the contract to describe the payload of an event. Producers and consumers of an event can trust that the event's payload matches the schema definition assigned to that event. Schemas define a type of payload through JSON, AVRO, XML, Binary, or Text. JSON, AVRO, and XML schemas have content that describes each property of the schema. The content is either in JSON or AVRO Schema format, or XSD/DTD format.</p>
    <p>Furthermore, you can search and view JSON schemas in a more <a href="event-portal-designer.htm#Viewing" class="link-internal">human-readable</a> format along with the actual schema source. This makes it easy for users to easily read, browse, and understand the schema contents without going through the source.</p>
    <h3><a name="Event5"/>Event</h3>
    <p>The event represents a business moment or an action that can be communicated with zero or more interested applications. The event is where you define metadata that describes and categorizes the event. An event is produced on a specific topic that must be defined for that event. From a modelling perspective, events reference payload schemas, and events are referenced by applications, thus forming the glue that binds applications together.</p>
    <p>It is important to note that an event (or an <i>event type</i>), as referred to in the <MadCap:variable name="Product-Names.eventportal_product_short"/> is different from an <i>event instance</i>. For more information on this topic, refer to <MadCap:xref href="#Event4">Event Type vs Event Instance</MadCap:xref>.</p>
    <h3><a name="Applicat2"/>Application</h3>
    <p>An application represents a piece of software that produces and consumes events. Applications connect to the event broker in an event-driven architecture and communicate with other applications via events. A single application represents a class of applications that are running the same code base; therefore, there is no need to create multiple applications for each instance in a cluster.</p>
    <p>When creating an application, you can specify the Application Type: Standard or Kafka Connector. </p>
    <ul>
      <li><b>Standard</b>: A standard application that connects to an event mesh.</li>
      <li><b>Kafka Connector</b>: A Kafka Connector is used for moving data into Kafka from other systems and out of Kafka into other systems.</li>
    </ul>
    <h4><a name="Kafka"/><MadCap:conditionalText MadCap:conditions="SAP.SapOnlyOutput">SAP Event Mesh </MadCap:conditionalText><MadCap:conditionalText MadCap:conditions="SAP.SapHideFromOutput">Solace </MadCap:conditionalText>to Kafka Connectors</h4>
    <p> A connector is used in Kafka for connecting Kafka brokers with external systems to stream data into or out of Apache Kafka. In the <MadCap:variable name="Product-Names.eventportal_product_short"/>, a Kafka Connector is an application class you select to configure associated published and/or subscribed events and a set of Kafka-native attributes.</p>
    <p>There are two sets of <MadCap:conditionalText MadCap:conditions="SAP.SapHideFromOutput">Solace</MadCap:conditionalText> <MadCap:conditionalText MadCap:conditions="SAP.SapOnlyOutput">SAP</MadCap:conditionalText> to Kafka connectors. Both these sets are comprised of a Source connector and a Sink connector to support bi-directional flow, although both connectors are not required. .</p>
    <dl>
      <dt><MadCap:conditionalText MadCap:conditions="SAP.SapHideFromOutput">Solace</MadCap:conditionalText><MadCap:conditionalText MadCap:conditions="SAP.SapOnlyOutput">SAP</MadCap:conditionalText>-Kafka Sink Connector</dt>
      <dd>The <MadCap:conditionalText MadCap:conditions="SAP.SapHideFromOutput">Solace</MadCap:conditionalText><MadCap:conditionalText MadCap:conditions="SAP.SapOnlyOutput">SAP</MadCap:conditionalText>-Kafka sink connector consumes Kafka records and publishes them as<MadCap:conditionalText MadCap:conditions="SAP.SapHideFromOutput"> Solace</MadCap:conditionalText> <MadCap:conditionalText MadCap:conditions="SAP.SapOnlyOutput">SAP</MadCap:conditionalText> events.</dd>
      <dd>
        <img class="img-border" src="../../Resources/Images/Event-Portal/solace-kafka-sink-connector.png" alt=" "/>
      </dd>
      <dd>The following objects and relationships are discovered:</dd>
      <dd><MadCap:variable name="Product-Names.cloud_product_short"/><![CDATA[                ]]></dd>
    </dl>
    <dl>
      <dd class="orderded">Logical Event Mesh
            </dd>
      <dd class="orderded">
                the topics and queues that the events are published to
            </dd>
      <dd><![CDATA[
                ]]><u>Kafka
</u><![CDATA[            ]]></dd>
      <dd class="orderded">
               Logical Event Mesh
            </dd>
      <dd class="orderded">
                topics
            </dd>
      <dd class="orderded">
                schemas
            </dd>
      <dd class="orderded">
                the sink connector
            </dd>
      <dd class="orderded">
               consumer group for the connector (along with the associated topic subscriptions)            </dd>
    </dl>
    <dl>
      <dt><MadCap:conditionalText MadCap:conditions="SAP.SapHideFromOutput">Solace</MadCap:conditionalText><MadCap:conditionalText MadCap:conditions="SAP.SapOnlyOutput">SAP</MadCap:conditionalText>-Kafka Source Connector</dt>
      <dd>The Solace-Kafka source connector consumes Kafka records and publishes them as Solace events.</dd>
      <dd>
        <img class="img-border" src="../../Resources/Images/Event-Portal/solace-kafka-source-connector.png" alt=" "/>
      </dd>
      <dd>The following objects and relationships are discovered:</dd>
      <dd>
        <MadCap:variable name="Variables.SAPCompanyName" style="text-decoration: underline;" MadCap:conditions="SAP.SapOnlyOutput"/>
        <u>
          <MadCap:variable name="Product-Names.pubsub_brand_only" MadCap:conditions="SAP.SapHideFromOutput"/>
        </u>
      </dd>
      <dd class="orderded">Logical Event Mesh</dd>
      <dd class="orderded">the topics and queues (and associated subscriptions) used as input to the connector</dd>
      <dd class="orderded">connector client (and associated subscriptions)</dd>
      <dd><u>Kafka
Discovery</u><![CDATA[           ]]></dd>
      <dd class="orderded">Logical Event Mesh</dd>
      <dd class="orderded">topics</dd>
      <dd class="orderded">schemas</dd>
      <dd class="orderded">the connector (along with the list of topics the connector is publishing to)</dd>
    </dl>
    <p>To learn more about Kafka connector, refer to the discussion on connectors in <a href="https://kafka.apache.org/documentation/#connect_overview" target="_blank" class="link-offsite">Kafka's documentation</a>. Refer to  <MadCap:xref href="event-portal-discovery.htm#ep-discovery-workflow-add-connector">Adding Connectors to an Application Domain</MadCap:xref> to learn how it's supported in the <MadCap:variable name="Product-Names.eventportal_product_short"/>.</p>
    <h2 class="with-rule"><a name="Event6"/><MadCap:variable name="Product-Names.eventportal_product_short"/> Tools</h2>
    <p>Use these tools to create, design, manage, discover, visualize, and share all events within your ecosystem.</p>
    <p><MadCap:xref href="event-portal-discovery.htm">[%=Product-Names.ep_discovery%]</MadCap:xref>: Discover and visualize events your event driven architecture from your event brokers. 
            Initial support is for discovery and the import of events, schemas, and application interactions from Apache Kafka, Confluent, and Amazon MSK.  Support for additional brokers types will follow.</p>
    <p><MadCap:xref href="event-portal-designer.htm">[%=Product-Names.ep_designer%]</MadCap:xref>: Design and view all aspects of your event-driven architecture.</p>
    <p><MadCap:xref href="event-portal-catalog.htm">[%=Product-Names.ep_catalog%]</MadCap:xref>: Browse for events, schemas, and applications defined in your environment using a searchable, sortable, and filterable interface.</p>
    <p><MadCap:xref href="event-api-products.htm">[%=Product-Names.eventapiproduct_long%]</MadCap:xref> : Bundle your events and make them available as Event API Products.</p>
    <h2 class="with-rule"><a name="Logical"/>Logical Event Mesh</h2>
    <p>A Logical Event Mesh (LEM) represents the <a href="../Event-Mesh/Mesh-Builder.htm" class="link-internal">event mesh</a> over which the associated published and subscribed events flow within an event-driven architecture. For event broker services, a LEM represents a Message VPN or a set of Message VPNs connected via DMR or MNR links. For Kafka brokers a LEM represents a Kafka broker cluster. Each LEM has a set of <a href="#Topic" class="link-internal">topic addresses</a> which are registered as published and/or subscribed to by applications connected to that event mesh. Based on the LEM, users can see the events that each application <a href="#Client" class="link-internal">client delivery endpoint</a> will attract through their respective subscriptions and therefore, know the events the application will be consuming in runtime, and how they will be consumed.</p>
    <p>An organization may have one or more LEMs of the same event broker type and/or different broker types. An application may use multiple LEM at the same time; for example, an application could be using a LEM for <MadCap:variable name="Product-Names.pubsub_brand_only" MadCap:conditions="SAP.SapHideFromOutput"/> <MadCap:variable name="Variables.SAPCompanyName" MadCap:conditions="SAP.SapOnlyOutput"/> event and another for Kafka event. It's important to remember that a LEM must have a specific broker type for the event routing behaviour to be correctly modelled in <MadCap:variable name="Product-Names.eventportal_product_short"/>. This allows for the associated Client Delivery Endpoint to be tailored to those specific broker types and constructs. For example, you can use consumer groups for Kafka CDEs, and Event Queues for  <MadCap:variable name="Variables.CompanyName"/> CDEs.</p>
    <p>The scope of a LEM for the following event broker types is as follows:</p>
    <h4>
      <MadCap:conditionalText MadCap:conditions="SAP.SapHideFromOutput">
        <b>
          <MadCap:variable name="Variables.CompanyName"/>
          <MadCap:variable name="Product-Names.pubsub_brand_only"/>
        </b>
      </MadCap:conditionalText>
      <MadCap:conditionalText MadCap:conditions="SAP.SapOnlyOutput">
        <b>SAP</b>
      </MadCap:conditionalText>
    </h4>
    <p>For <MadCap:conditionalText MadCap:conditions="SAP.SapHideFromOutput"><MadCap:variable name="Product-Names.pubsub_brand_only"/> event brokers and </MadCap:conditionalText><MadCap:variable name="Variables.SAPCompanyName" MadCap:conditions="SAP.SapOnlyOutput"/> <MadCap:variable name="Product-Names.broker_cloud_short"/>s, it represents the model of a Message VPN or a set of DMR or MNR meshed Message VPNs (an event mesh). The topic level delimiter is always a forward slash symbol (<code>/</code>).</p>
    <h4>
      <b>Kafka</b>
    </h4>
    <p>For Kafka, it represents a cluster of event brokers. That is, the mesh over which the associated published and subscribed events flow. If you have more than one Kafka Cluster, you will have one Logical Event Mesh per Cluster. The topic level delimiter is configurable and can be set to whatever the organization has decided to use. Dots (<code>.</code>) and Underscores (<code>_</code>) are commonly used.</p>
    <h2 class="with-rule"><a name="Topic3"/>Topic Tree</h2>
    <p>Topic Tree represents all topic addresses that will be published within a <MadCap:xref href="#Logical">Logical Event Mesh</MadCap:xref> (LEM). The scope for a topic address is limited to the LEM in which they are targeted or published. For <MadCap:variable name="Product-Names.pubsub_brand_only" MadCap:conditions="SAP.SapHideFromOutput"/> <MadCap:conditionalText MadCap:conditions="SAP.SapOnlyOutput">SAP </MadCap:conditionalText>events, you can only associate one event per topic address. In other words, it cannot be published to multiple Logical Event Meshes. To model this, you will need to create a separate event with a slightly different name and the same topic address with a different associated target Logical Event Mesh. However, for Kafka-based events, you can have multiple events with the same topic address but different schemas.</p>
    <p>The primary purpose of a topic tree is to enable the system, and therefore users to evaluate <a href="#Client" class="link-internal">Client Delivery Endpoint</a> subscriptions and determine the topic addresses (and therefore which events)  the associated consuming applications will attract. The Topic Tree inherits the topic delimiter from the Logical Event Mesh.</p>
    <p>An organization should first define a topic hierarchy (refer to our <MadCap:xref href="../../Messaging/Topic-Architecture-Best-Practices.htm">Topic Architecture Best Practices</MadCap:xref> guide) and then create the topic addresses based on the topic hierarchy. These addresses are placed within a bounded context of a LEM against which subscriptions can be evaluated.</p>
    <h3><a name="Topic"/>Topic Address</h3>
    <p>Topic Address is a set of <MadCap:xref href="#Topic2">Topic Levels</MadCap:xref> that are used to construct a topic for a published event. The events defined in the <MadCap:variable name="Product-Names.eventportal_product_short"/> must have a topic address for the runtime event broker to route the events to interested parties. </p>
    <p>Based on the topic address, a Client Delivery Endpoint (CDE) receives the published event depending on the CDE's subscriptions. There can be zero or more CDEs with subscriptions that match an event published with the Topic Address.</p>
    <p>An event is only available for consumption within a Logical Event Mesh if it fulfills the following requirements:</p>
    <ul>
      <li>it is targeted to a Logical Event Mesh</li>
      <li>a topic address has been created for it</li>
    </ul>
    <p>Once the topic address is created, it will be added to the Topic Tree and evaluated against the Logical Event Mesh subscriptions.  All the appropriate event to application relationships are automatically determined and updated.</p>
    <h3><a name="Topic2"/>Topic Level</h3>
    <p>A topic level is a component of a topic address that can be a literal value or a variable. A variable is a placeholder that is substituted for a concrete value by publishing applications at runtime. A variable type topic level can be bounded (with a defined value set) or it can be unbounded. </p>
    <p>If a topic level is static, then you can use a literal topic level to represent it. However, you could also define an enum with a specific set of values that do not have to be replaced with constrained values by applications at runtime.  Whether to use literal or variable is up to the person designing the topic address. </p>
    <h3>Topic </h3>
    <p>Topics are a means of classifying information, and in practice they're simply strings that are composed of one or more levels. For more information, refer to <MadCap:xref href="../../Get-Started/what-are-topics.htm">Understanding Topics</MadCap:xref>.</p>
    <h3>Topic Subscriptions</h3>
    <p>A Topic subscription is a string used to attract events that are published on an event mesh.  A topic subscription can contain wildcards, used to match multiple topics or hierarchies of topics. Wildcard characters and matching behavior vary between messaging protocols.</p>
    <h2 class="with-rule"><a name="Client"/>Client Delivery Endpoints</h2>
    <p>A Client Delivery Endpoint (CDE) represents  the location on an Event Mesh that is used by an application to consume events. For this to happen, the following must be defined in the CDE:</p>
    <ul>
      <li>a Logical Event Mesh for the CDE must be specified</li>
      <li>the type of the CDE must be specified</li>
      <li>the CDE must have subscriptions to consume events</li>
      <li>a CDE can only be associated with an Application and each CDE can only be associated once with an Application</li>
    </ul>
    <p>A CDE is scoped to a single Logical Event Mesh, however, an application may have relationships with zero or more CDEs. In the case where the CDE represents a physical endpoint (a queue or topic endpoint; for example, in <MadCap:conditionalText MadCap:conditions="SAP.SapHideFromOutput"><MadCap:variable name="Product-Names.pubsub_brand_only"/> event broker or </MadCap:conditionalText> <MadCap:variable name="Product-Names.broker_cloud_short"/>), the name of the endpoint is used for the CDE.</p>
    <p>The following CDEs are currently supported in <MadCap:variable name="Product-Names.eventportal_product_short"/>: </p>
    <dl>
      <dt><a name="Event"/>Event Queue</dt>
      <dd>An Event Queue is similar to a <a href="../../Get-Started/topic-endpoints-queues.htm"><a href="../../Get-Started/topic-endpoints-queues.htm" class="link-internal" MadCap:conditions="SAP.SapHideFromOutput">Queue</a></a><a href="../../Get-Started/topic-endpoints-queues.htm" class="link-internal" MadCap:conditions="SAP.SapOnlyOutput">Queue</a>, but it's specifically used for pub/sub message exchange pattern. It does not support request/reply or point-to-point message exchange patterns. </dd>
      <dt>Durable Topic Endpoint</dt>
      <dd>Durable topic endpoints are provisioned objects on the event broker that have a life span independent of a particular client session.<MadCap:conditionalText MadCap:conditions="SAP.SAPTempHide"> To learn more, refer to <MadCap:xref href="../../Messaging/Guaranteed-Msg/Endpoints.htm#Endpoint_Durability">Endpoint Durability</MadCap:xref>.</MadCap:conditionalText></dd>
      <dt>Direct Client Endpoint</dt>
      <dd>Direct Client Endpoints are client connections with one or more subscriptions.   It is a essentially a direct messaging client—a consuming or subscribing client without a queue or topic endpoint.</dd>
      <dt>Consumer Group (Kafka only)</dt>
      <dd>Client username and client name is the same as the event brokers, don't apply to Connector Groups as that concept doesn't exist in Kafka. <MadCap:variable name="Product-Names.eventportal_product_short"/> supports the concept of Kafka's consumer groups. </dd>
      <dd>A consumer group is used by Kafka to group consumers into a logical subscriber for a topic. In <MadCap:variable name="Product-Names.eventportal_product_short"/>, you can model consumer groups in  <MadCap:variable name="Product-Names.ep_designer"/>. This enables the <MadCap:variable name="Product-Names.eventportal_product_short"/>'s runtime discovery to associate a discovered consumer group to an existing application. Kafka consumers that belong to the same consumer group share a group ID. The consumers in a group divide the topic partitions, as fairly as possible, so that each consumer consumes only a single partition from the group. </dd>
      <dd>To learn how you can set up consumer groups in the <MadCap:variable name="Product-Names.eventportal_product_short"/>, see <MadCap:xref href="event-portal-discovery.htm#Mapping">Mapping Consumer Groups to Client Delivery Endpoints</MadCap:xref>. You can also visit the Kafka's documentation to learn more about <a href="https://docs.confluent.io/current/clients/consumer.html#consumer-groups" target="_blank" class="link-offsite">consumer groups</a>.</dd>
    </dl>
    <h2 class="with-rule"><a name="Event4"/>Event Type vs Event Instance</h2>
    <p>An <i>event type</i> (or event as it is referred to in <MadCap:variable name="Product-Names.eventportal_product_short"/>) represents a class of events produced in an event-driven architecture. The event type is made up of its topic and schema that represents the allowed payload for the event.</p>
    <p>An <i>event instance</i> is a specific instance of an event that is produced. An event instance has an event type. It conforms to the schema of the event type and is produced on a topic defined for the event type. Over the lifecycle of an application, many event instances are produced and consumed.</p>
    <h2 class="with-rule"><a name="Shared"/>Shared Events and Schemas
        </h2>
    <p>By default, you can only reference events and schemas within their own application domain. For another application domain to reference your events and schemas, the event or schema must be marked as shared. For example, imagine a situation where there are two application domains modeled in <MadCap:variable name="Product-Names.eventportal_product_short"/>: the Weather Events and the Traffic Events. Say, an event is created in the Weather Events application domain called the Blizzard. Since the Traffic Events application domain should be able to consume the Blizzard event, the creator of the Blizzard marks the event as shared. Now when an application is created in the Traffic Event application domain, it can choose to publish or subscribe to the Blizzard event. If it were not marked as shared, it would not be allowed to reference by applications in the Traffic Events application domain.</p>
    <h2 class="with-rule">
      <a name="discovery-agent"/>
      <MadCap:variable name="Product-Names.discovery_agent"/>
    </h2>
    <p>You can use the <MadCap:variable name="Product-Names.discovery_agent"/> to run a <MadCap:variable name="Product-Names.ep_discovery"/> scan against your event broker. The agent will connect to your event broker to scan your event-driven architecture using a specified set of topic subscriptions. The gathered data is generated as a JSON file (<MadCap:variable name="Product-Names.ep_discovery"/> file), which you can upload into <MadCap:variable name="Product-Names.eventportal_product_short"/>. </p>
    <p>The following event brokers are currently supported: Apache Kafka, Confluent, Amazon MSK, and <MadCap:conditionalText MadCap:conditions="SAP.SapOnlyOutput">SAP <MadCap:variable name="Product-Names.broker_cloud_short"/>s </MadCap:conditionalText><MadCap:conditionalText MadCap:conditions="SAP.SapHideFromOutput"><MadCap:conditionalText MadCap:conditions="SAP.SapHideFromOutput"><MadCap:variable name="Product-Names.cloud_product_long"/></MadCap:conditionalText><MadCap:conditionalText MadCap:conditions="SAP.SapOnlyOutput"><MadCap:variable name="Product-Names.cloud_product_firstuse_initialcase"/></MadCap:conditionalText></MadCap:conditionalText> <MadCap:variable name="Product-Names.broker_cloud_short"/>s.</p>
    <p class="Note" MadCap:conditions="Default.HideFromAllOutput"><MadCap:variable name="Product-Names.discovery_agent"/> for <MadCap:variable name="Product-Names.pubsub_brand_only"/> event brokers and <MadCap:variable name="Product-Names.cloud_product_short" MadCap:conditions="SAP.SapOnlyOutput"/> <MadCap:variable name="Product-Names.broker_cloud_short"/>s is available in a Preview release stage.  At present, you can only run a scan and generate a Discovery file.  Uploading it to the <MadCap:variable name="Product-Names.eventportal_product_short"/>'s <MadCap:variable name="Product-Names.ep_discovery"/> Staging area and committing the <MadCap:variable name="Product-Names.ep_discovery"/> data to <MadCap:variable name="Product-Names.ep_designer"/>/<MadCap:variable name="Product-Names.ep_catalog"/>is not yet supported.</p>
    <p>You can install the agent locally and use it to scan your EDA and generate a <MadCap:variable name="Product-Names.ep_discovery"/> file. To install the agent or learn how to run a <MadCap:variable name="Product-Names.ep_discovery"/> scan, refer to <MadCap:xref href="event-portal-discovery.htm#Installi">Installing the Offline Discovery Agent</MadCap:xref>.</p>
    <h3><a name="Informat"/>Information <MadCap:variable name="Product-Names.discovery_agent"/> Captures and Uploads</h3>
    <p>The information the agent gathers during a <MadCap:variable name="Product-Names.ep_discovery"/> scan depends on the event broker type. </p>
    <h4>
      <MadCap:variable name="Product-Names.pubsub_brand_only"/>
      <MadCap:variable name="Product-Names.broker_cloud_short_title"/>
    </h4>
    <p>The following data/metadata is returned in the <MadCap:variable name="Product-Names.ep_discovery"/> scans:</p>
    <table style="width: 100%;mc-table-style: url('../../Resources/TableStyles/Table_Num.css');" class="TableStyle-Table_Num" cellspacing="0">
      <col class="TableStyle-Table_Num-Column-Column1"/>
      <col class="TableStyle-Table_Num-Column-Column1"/>
      <thead>
        <tr class="TableStyle-Table_Num-Head-Header1">
          <th class="TableStyle-Table_Num-HeadE-Column1-Header1">Information Gathered By Agent</th>
          <th class="TableStyle-Table_Num-HeadD-Column1-Header1">Description</th>
        </tr>
      </thead>
      <tbody>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">Broker</td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>The<MadCap:conditionalText MadCap:conditions="SAP.SapHideFromOutput"> event broker or </MadCap:conditionalText><MadCap:variable name="Product-Names.broker_cloud_short"/> information taken from the input data specified by the user, which is also uploaded in the <MadCap:variable name="Product-Names.ep_discovery"/> file.</p>
            <pre xml:space="preserve">"broker": {
"	brokerType": "solace",
	"hostname": "mySolaceHost.solace.com"
	"additionalAttributes": {
"	vpnName": "myVpnName" 
	}
}
</pre>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">Clients</td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>An active or inactive messaging client in the event broker. A client has a top level attribute, which is used to indicate of the client is a consumer or his client type implies message flow direction in the context of relationships with channel objects.</p>
            <p> Te following client type information is captured:</p>
            <ul>
              <li>
                <code>clientType: Client Application</code>
              </li>
              <li>
                <code>clientUserName: myClientUsername</code>
              </li>
              <li>
                <code>clientProfleName: myClientProflleName</code>
              </li>
              <li>
                <code>aclProfileName: myAclProfileName</code>
              </li>
            </ul>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">Channels</td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>A channel represents the event broker entities that are responsible for the transmission and storage of messages. </p>
            <p>The channel types include: </p>
            <ul>
              <li>Topics</li>
              <li> Queues</li>
              <li>Topic Endpoints </li>
            </ul>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyE-Column1-Body1">Subscriptions</td>
          <td class="TableStyle-Table_Num-BodyD-Column1-Body1">
            <p>Subscriptions represents a potentially unbounded “channel space” described by a set of criteria (topic strings with wildcards, routing keys, etc.)</p>
            <p>Subscription types</p>
            <ul>
              <li> client to topic subscription </li>
              <li> queue to topic subscription</li>
            </ul>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1" MadCap:conditions="Default.HideFromAllOutput">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">Schema</td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>The schema of the message payload (and or key). Can be inferred from a message or discovered from a schema registry.</p>
            <p>The following attributes are included:</p>
            <ul>
              <li><code>content</code>—the schema content</li>
              <li><code>schemaType</code>—type of schema.</li>
              <li><code>hints</code>—a pre-defined set of hints to help upper-layer applications process the schema.</li>
              <li><code>primitive</code>—true if the schema is a primitive type</li>
            </ul>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyB-Column1-Body1">Object Relationships</td>
          <td class="TableStyle-Table_Num-BodyA-Column1-Body1">
            <p>The object relations represent relationship between two or more to-level objects. </p>
            <p>The following relationships are captured:</p>
            <ul>
              <li>
                <code>clientToSubscriptionRelationship</code>
                <li>
                  <code>channelToSubscriptionRelationship</code>
                </li>
                <li>
                  <code>clientToChannelRelationship</code>
                </li>
                <li>
                  <code>channelToChannelRelationship</code>
                </li>
              </li>
            </ul>
          </td>
        </tr>
      </tbody>
    </table>
    <h4>Kafka Broker</h4>
    <p>The following data/metadata is returned in the <MadCap:variable name="Product-Names.ep_discovery"/> scans:</p>
    <table style="width: 100%;mc-table-style: url('../../Resources/TableStyles/Table_Num.css');" class="TableStyle-Table_Num" cellspacing="0">
      <col class="TableStyle-Table_Num-Column-Column1"/>
      <col class="TableStyle-Table_Num-Column-Column1"/>
      <thead>
        <tr class="TableStyle-Table_Num-Head-Header1">
          <th class="TableStyle-Table_Num-HeadE-Column1-Header1">Information Gathered By Agent</th>
          <th class="TableStyle-Table_Num-HeadD-Column1-Header1">Description</th>
        </tr>
      </thead>
      <tbody>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">Topics</td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">A list of topic names.</td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">Connectors</td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>A list of connectors with the following configuration data:</p>
            <ul>
              <li>connector class</li>
              <li>connector type</li>
              <li>maximum thread allocation</li>
            </ul>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyH-Column1-Body1">Consumer Groups</td>
          <td class="TableStyle-Table_Num-BodyG-Column1-Body1">
            <p>A list of consumer groups with a flag indicating if they are simple consumers.</p>
          </td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyE-Column1-Body1">Schemas</td>
          <td class="TableStyle-Table_Num-BodyD-Column1-Body1">A list of schemas. In the case of a string schema (non-json format), the contents of the message will be included.</td>
        </tr>
        <tr class="TableStyle-Table_Num-Body-Body1">
          <td class="TableStyle-Table_Num-BodyB-Column1-Body1">Object Relationships</td>
          <td class="TableStyle-Table_Num-BodyA-Column1-Body1">
            <p>The object relations represent relationship between two or more to-level objects. </p>
            <p>The following relationships are captured:</p>
            <ul>
              <li>
                <code>connectorToTopicAssociations</code>
              </li>
              <li>
                <code>consumerGroupToTopicAssociations</code>
              </li>
              <li>
                <code>topicToSchemaAssociations</code>
              </li>
            </ul>
          </td>
        </tr>
      </tbody>
    </table>
    <h2 class="with-rule"><a name="Primitive-Type"/>Primitive Types</h2>
    <p>Some message payloads consist of primitive types such as <code>String</code> and <code>Numbers</code>, rather than more complex structures (JSON or XML). <MadCap:variable name="Product-Names.eventportal_product_short"/> supports primitive event types so that you can model your events (for example, Kafka topics) with payloads that are simple primitives. Primitive types for message payloads are automatically detected in the <MadCap:variable name="Product-Names.ep_discovery"/> and can be committed or imported into <MadCap:variable name="Product-Names.ep_designer"/>. Likewise, you can also create and edit an event to use a primitive type in the <MadCap:variable name="Product-Names.ep_designer"/>. Using AsyncAPI, you can generate an AsyncAPI specification for the application associated with an event with primitive payloads.</p>
    <p>The following primitive types are currently supported in <MadCap:variable name="Product-Names.eventportal_product_short"/>:</p>
    <ul>
      <li>Avro: <code>Null</code>, <code>Boolean</code>, <code>Int</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>, <code>Byte</code>, <code>String</code></li>
      <li>JSON: <code>Null</code>, <code>Boolean</code>, <code>Number</code>, <code>String</code></li>
    </ul>
    <p>To learn how to use a Primitive Type when designing an event, see <MadCap:xref href="event-portal-designer.htm#manage-events">Managing Events</MadCap:xref>.</p>
    <h2 class="with-rule"><a name="Multiple2"/>Multiple Record Types</h2>
    <p>It is common for Kafka-based applications to publish events to the event broker on the same topic that does not share the same schema. In <MadCap:variable name="Product-Names.eventportal_product_short"/>, you can discover, re-discover, and stage different topics with more than one record type. In other words, topics that have multiple records with different payload schemas are discovered in <MadCap:variable name="Product-Names.ep_discovery"/>. The payload schema could be JSON, Avro, XML, text, or Binary. Discovered events for the same topic are uniquely named to differentiate each event before committing them into the <MadCap:variable name="Product-Names.ep_designer"/> as events. Once committed, the topic to schema association occurs in the backend, which can then be visualized in <MadCap:variable name="Product-Names.ep_designer"/>.</p>
    <p>To learn how to discover and commit your EDA into <MadCap:variable name="Product-Names.eventportal_product_short"/>, refer to <MadCap:xref href="event-portal-discovery.htm">[%=Product-Names.ep_discovery%]</MadCap:xref>.</p>
    <h2 class="with-rule"><a name="Tags"/>Tags</h2>
    <p>Applications, events and schemas all have the option to have tags associated with them. Searching for a tag name in <MadCap:variable name="Product-Names.ep_catalog"/> will find all the objects associated with that tag.</p>
    <p>Tags can be a great way to share information with other members of your organization by grouping sets of objects together. Here are some examples of how you can use tags:</p>
    <ul>
      <li>Create a tag called <code>Java</code> and set it against all of your Java-based applications</li>
      <li>Create a tag called <code>User</code> and tag all of your schemas related to users</li>
      <li>Create a tag called <code>Sign in Flow</code> and tag the series of events and applications that are involved in the sign in flow for your application</li>
    </ul>
    <p>In the future release of the <MadCap:variable name="Product-Names.eventportal_product_short"/>, <MadCap:variable name="Product-Names.ep_designer"/> will have the ability to filter applications and events based on the tags applied to them. This will give another layer of customization to visualize your event-driven architectures.</p>
    <h2 class="with-rule"><a name="Revision"/>Revision History</h2>
    <p> Revision history track the changes to objects in <MadCap:variable name="Product-Names.eventportal_product_short"/>. Any time an application, event or schema is updated, it creates a new revision. For schemas, you can perform additional tasks such as creating multiple versions of a particular schema and advanced version control management. Refer to <MadCap:xref href="#Multiple">Schema Versions and Version Control</MadCap:xref> for more information.</p>
    <p>You can restore an old revision of an object at any point. The act of restoring an object to a previous revision creates a new revision of that object. For example, an object whose current revision is at Rev 2, when restored to Rev 1, will result in it having three revisions. The new Rev 3 will be the same as Rev 1 since it was restored from it.</p>
    <p>There are few exceptions that you should consider when using the revision history of an object:</p>
    <ul>
      <li>Owner and tag information of an object is not included in the revision history. Changing the owners or tags of an object will not create a new revision of the object.</li>
      <li>
                Restoring to a revision of an object whose associations have changed will not change the associated objects. For example, imagine an event and schema that have both undergone ten revisions. At the time of the second revision of the event, the schema was on its first revision. Reverting the event to its second revision will not return the schema to its first revision, it will continue to be its tenth revision.
            </li>
      <li>Application domains do not track revision history. Instead, if you need to revert an application domain and all of its contained objects to a point in time, it is recommended to use the import/export functionality.</li>
    </ul>
    <p>For tutorials, refer to <MadCap:xref href="event-portal-designer.htm#Performi">Managing Object Revisions</MadCap:xref>.</p>
    <h3><a name="Multiple"/>Schema Versions and Version Control</h3>
    <p>You can create schemas with our without versions. When using schema versions, you can create and store multiple versions of the same schema, which can be used in your EDAs that require two or more versions of a particular schema. Revision History is support with schema version control, such as saving revisions of each schema, viewing changes in the revisions, and reverting to an older revision.</p>
    <p>For additional information and tutorials, see <MadCap:xref href="event-portal-designer.htm#Create3">Managing Schemas</MadCap:xref> .</p>
    <h3>Archive Objects and Revisions</h3>
    <p>When you delete an object, it will be archived for ninety days, along with its associated revisions. You can restore the deleted object and its associated revisions anytime within the ninety days.</p>
    <p>To learn more, refer to <MadCap:xref href="event-portal-designer.htm#Deleting">Deleting an Object</MadCap:xref>.</p>
    <h2 class="with-rule"><a name="Role-Bas"/>Role-Based Access Control (RBAC)</h2>
    <p><MadCap:variable name="Product-Names.eventportal_product_short"/> supports the ability to apply access controls to application domains through <MadCap:variable name="Product-Names.ep_designer"/>. <MadCap:variable name="Product-Names.eventportal_product_short"/>'s role-based access control (RBAC) helps you manage who has access to applications domains and their resources and what they can do with it. For example, enterprise architects could be responsible for the entire event-driven architecture (EDA) and its assets, and therefore require Administrator or <MadCap:variable name="Product-Names.ep_manager"/> role to view and modify all application domains. On the other hand, application developers may be responsible for specific parts of the EDA, and therefore may only require access to view or edit one or more specific application domains. In that case, they can be assigned <MadCap:variable name="Product-Names.ep_user"/> role with Viewer, Editor or Manager level access to specific application domains. </p>
    <p>For more information on <MadCap:variable name="Product-Names.eventportal_product_short"/> RBAC, refer to <MadCap:xref href="event-portal-designer.htm#Creating">Managing Application Domains</MadCap:xref>.</p>
    <h2 class="with-rule"><a name="AsyncAPI"/>AsyncAPI</h2>
    <p>AsyncAPI is an open-source initiative that seeks to improve the current state of Event-Driven Architectures (EDA). Using AsyncAPI allows development teams to create applications that communicate asynchronously through events more easily. The core of AsyncAPI is a specification that describes how to create a document that explains the inner workings of an event-driven API.</p>
    <p>You can use an AsyncAPI specification for many functions, such as:</p>
    <ul>
      <li>Generating documentation</li>
      <li>Generating code</li>
      <li>Validating events received by your application</li>
      <li>Applying API management policies</li>
    </ul>
    <p>Learn more about AsyncAPI on their website at <a href="https://www.asyncapi.com/" target="_blank" class="link-offsite">https://www.asyncapi.com</a>.</p>
    <h3>AsyncAPI and the <MadCap:variable name="Product-Names.eventportal_product_short"/></h3>
    <p><MadCap:variable name="Product-Names.eventportal_product_short"/> natively supports the AsyncAPI 2.0.0 specification and applications can be exported into an AsyncAPI document. You can export applications in JSON and YAML; the two supported formats of AsyncAPI.</p>
    <p>To learn how to generate an AsyncAPI document for an application, refer to <MadCap:xref href="event-portal-designer.htm#Exportin">Generating an AsyncAPI</MadCap:xref>.</p>
    <h2 class="with-rule"><a name="REST"/>REST API</h2>
    <p><MadCap:variable name="Product-Names.eventportal_product_short"/> provides a RESTful API that you can use to manage your data in the <MadCap:variable name="Product-Names.cloud_product_short"/>. Use the REST API to integrate other applications, systems, or client applications with <MadCap:variable name="Product-Names.eventportal_product_short"/>, and model or retrieve your event-driven architectures from your own client applications. </p>
    <p>For more information, refer to the <MadCap:xref href="Event-Portal-REST-API.htm"><MadCap:variable name="Product-Names.eventportal_product_short"/> REST API</MadCap:xref> documentation.</p>
    <h2 class="with-rule">Related Topics </h2>
    <ul>
      <li>Learn the basics of <MadCap:variable name="Product-Names.ep_discovery"/>, <MadCap:variable name="Product-Names.ep_designer"/>, and <MadCap:variable name="Product-Names.ep_catalog"/>: <MadCap:xref href="../ggs_signup.htm">Getting Started with
        [%=Product-Names.cloud_product_long%]</MadCap:xref></li>
      <li>Already completed the getting started tutorials? Find advanced topics in the following pages: <MadCap:xref href="event-portal-discovery.htm"><MadCap:variable name="Product-Names.ep_discovery"/></MadCap:xref>, <MadCap:xref href="event-portal-designer.htm"><MadCap:variable name="Product-Names.ep_designer"/></MadCap:xref>, and <MadCap:xref href="event-portal-catalog.htm">[%=Product-Names.ep_catalog%].</MadCap:xref></li>
      <li>Overview information for <MadCap:variable name="Product-Names.eventportal_product_short"/> APIs, sample codes, and reference guides: <MadCap:xref href="Event-Portal-REST-API.htm"><MadCap:variable name="Product-Names.eventportal_product_short"/> REST API</MadCap:xref>.</li>
      <li>Checkout the best practices for creating an event topic architecture: <MadCap:xref href="../../Messaging/Topic-Architecture-Best-Practices.htm">Topic Architecture Best Practices</MadCap:xref>.</li>
    </ul>
  </body>
</html>
