define({"1014":{y:0,u:"../API/API-Developer-Guide/Creating-Custom-Header-Fields.htm",l:-1,t:"Creating Custom Message Header Fields",i:0.000261075302953918,a:"To create a custom message header field, you can create a map with custom user properties fields. The user properties are carried in the message separate from the payload. JCSMP To create custom message header fields, first create a user properties map in the same manner as you would a typical SDT ..."},"1015":{y:0,u:"../API/API-Developer-Guide/Using-Local-Transactions.htm",l:-1,t:"Using Local Transactions",i:0.00136144270706085,a:"This section describes how to use transacted sessions to publish and/or receive a series of Guaranteed messages in a single atomic unit known as a local transaction. Local transactions only rely on a single resource (the event broker) to provide messaging clients with service. Local Transactions can ..."},"1016":{y:0,u:"../API/API-Developer-Guide/Creating-Transacted-Sess.htm",l:-1,t:"Creating Transacted Sessions",i:0.000186324170149524,a:"A client can create one or more Transacted Sessions within an existing Session. A Transacted Session always has exactly one active Transaction. Once a Transacted Session is created, a Transaction automatically begins within that Transacted Session. Within a Transacted Session, a client can create a ..."},"1017":{y:0,u:"../API/API-Developer-Guide/Publishing-Messages-inT.htm",l:-1,t:"Publishing Messages in Transactions",i:0.000265512329862361,a:"To publish Guaranteed messages in a Transaction, a producer flow must first be established in the Transacted Session: For JCSMP, the client application must acquire an XMLMessageProducer from the Transacted Session. For the Java RTO, C, and .NET APIs, when a Transacted Session is successfully ..."},"1018":{y:0,u:"../API/API-Developer-Guide/Consuming-Msgs-in-Transactions.htm",l:-1,t:"Consuming Messages in Transactions",i:0.000265512329862361,a:"To consume Guaranteed messages in a Transaction, a client must create a consumer Flow within the Transacted Session through one of the methods or functions listed below to bind to the destination endpoint that the messages are spooled to. Guaranteed messages can then be received from the destination ..."},"1019":{y:0,u:"../API/API-Developer-Guide/Completing-Transactions.htm",l:-1,t:"Completing Transactions",i:0.000324043410441619,a:"Messages that are published and received on a Transaction are staged on the Solace PubSub+ event broker. A Transaction can either be: Completed through a commit operation:  Committing Transactions Canceled through a rollback operation:  Rolling Back Transactions Committing Transactions When a commit ..."},"1020":{y:0,u:"../API/API-Developer-Guide/Closing-Transactions.htm",l:-1,t:"Closing Transacted Sessions",i:0.000186324170149524,a:"To cleanly terminate a Transacted Session, the client application should commit the current Transaction, and then close the Transacted Session. If a client application closes a Transacted Session without first committing the current Transaction, the API rolls back that Transaction, and it does not ..."},"1021":{y:0,u:"../API/API-Developer-Guide/Delayed-Redelivery.htm",l:-1,t:"Delayed Redelivery",i:0.000186324170149524,a:"To give applications time to recover from a temporary inability to process a message, this feature allows for the delayed redelivery of messages to clients who are consuming guaranteed messages using local transactions. Delayed redelivery is controlled by a timer and is triggered by a ..."},"1022":{y:0,u:"../API/API-Developer-Guide/Thread-Safety.htm",l:-1,t:"Thread Safety",i:0.000186324170149524,a:"The PubSub+ Messaging APIs ensure that certain API elements are thread-safe, while others are the responsibility of the application developer. The table below lists who is responsible for the thread safety of each API element:    Contexts, Sessions, and Flows: Thread Safe  Your enterprise might need ..."},"1023":{y:0,u:"../API/API-Developer-Guide/API-Threading.htm",l:-1,t:"API Threading\n",i:0.000291337747658429,a:"API Threading\n The APIs use a Context to organize communications between a client application and a Solace PubSub+ event broker. A Context acts as a container for configuring one or more Sessions and handling Session-related events, and it encapsulates threads that drive network I/O and message ..."},"1024":{y:0,u:"../API/API-Developer-Guide/Threading-When-Publishin.htm",l:-1,t:"Threading When Publishing Messages",i:0.000186324170149524,a:"When the event broker successfully receives Guaranteed messages, it returns acknowledgments to the API. It does not return acknowledgments for Direct messages. (The exception to this is publishing Direct messages using JCSMP’s non-streaming publishing mode.) The Context uses a processing thread to ..."},"1025":{y:0,u:"../API/API-Developer-Guide/Threading-When-Receiving.htm",l:-1,t:"Threading When Receiving Messages",i:0.000259987760271367,a:"When receiving published messages, the Context uses a processing thread to read messages off the socket, parse them, and then, depending on the messaging API and whether a synchronous or asynchronous mode is used, enqueue the messages for delivery or consumption, or perform customer notification and ..."},"1026":{y:0,u:"../API/API-Developer-Guide/Context-Propagation-Distributed-Tracing.htm",l:-1,t:"Context Propagation for Distributed Tracing",i:0.00053813272291017,a:"Distributed tracing allows your enterprise applications to trace the flow of messages as they travel from your publisher, through the event mesh and to the receiving application.  For a detailed overview see  Distributed Tracing  .  For  information about version requirements, see  Distributed ..."},"1027":{y:0,u:"../API/API-Developer-Guide/API-Best-Practices.htm",l:-1,t:"API Best Practices",i:0.000239626203375077,a:"This section discusses best practices you can use when developing applications with the Solace C, JCSMP, Java RTO, .NET, JavaScript and Node.js APIs. C API Best Practices JCSMP Best Practices Java RTO API Best Practices .NET API Best Practices JavaScript \u0026 Node.js APIs Best Practices Replication ..."},"1028":{y:0,u:"../API/API-Developer-Guide/C-API-Best-Practices.htm",l:-1,t:"C API Best Practices",i:0.000847234365867464,a:"The following are some of the best practices for the PubSub+ Messaging API for C. The practices are divided into the following categories: General Best Practices Threading File Descriptor Management Initializing Data Structures with Provided Macros Memory Management Session Establishment Selecting ..."},"1029":{y:0,u:"../API/API-Developer-Guide/Java-API-Best-Practices.htm",l:-1,t:"JCSMP Best Practices",i:0.000237889217584267,a:"General Best Practices Tuning Guidelines for Guaranteed Messaging Reductions in the rate at which clients receive messages can occur when a high volume of Guaranteed messages (particularly when they are large messages) is received over many Flows. In this situation, the number of Flows used and the ..."},"1030":{y:0,u:"../API/API-Developer-Guide/Java-RTO-API-Best-Practices.htm",l:-1,t:"Java RTO API Best Practices",i:0.000420062852642552,a:"Context and Session Threading Model Considerations Recommendation Use the \u0027One Session, One Context\u0027 threading model whenever possible. The \u0027Multiple Session, One Context\u0027 and \u0027Multiple Sessions, Multiple Contexts\u0027 models can potentially increase message processing throughput, but at the expense of ..."},"1031":{y:0,u:"../API/API-Developer-Guide/-NET-Best-Practices.htm",l:-1,t:".NET API Best Practices",i:0.000406557656497726,a:"General Best Practices Tuning Guidelines for Guaranteed Messaging Reductions in the rate at which clients receive messages can occur when a high volume of Guaranteed messages (particularly when they are large messages) is received over many Flows. In this situation, the number of Flows used and the ..."},"1032":{y:0,u:"../API/API-Developer-Guide/JavaScript-Nodejs-APIs-Best-Practices.htm",l:-1,t:"JavaScript \u0026 Node.js APIs Best Practices",i:0.000215421786470637,a:"Do Not Block in Event Handlers and Listeners Since JavaScript is single threaded, applications must not block in and should return as quickly as possible from message receive, event, and timer handler or listener code. Behavior Profiles Generally, Solace recommends using the latest version\u0027s factory ..."},"1033":{y:0,u:"../API/API-Developer-Guide/Replication-BP.htm",l:-1,t:"Replication Best Practices",i:0.000229129739839772,a:"This section describes considerations that should be made when your client applications are to be used with Solace PubSub+ event brokers using the Replication facility, which provides a data center redundancy and disaster recovery solution for Solace PubSub+. Messaging API Versions It is strongly ..."},"1034":{y:0,u:"../API/API-Developer-Guide/Redundancy-BP.htm",l:-1,t:"Redundancy Best Practices",i:0.00029517365286029,a:"This section describes considerations that should be made when your client applications are to be used with PubSub+ event brokers using redundancy features, such as high availability (HA). High availability involves using two brokers, a primary and a backup, that work together to provide seamless ..."},"1035":{y:0,u:"../API/API-Developer-Guide/cache/using-pubsub-cache.htm",l:-1,t:"Using PubSub+ Messaging APIs with PubSub+ Cache",i:0.000444554105547683,a:"If you have PubSub+ Cache, you can use the PubSub+ Messaging APIs to make cache requests for topics. The cache requests must include the name of the Distributed Cache, Cache Cluster, or PubSub+ Cache Instance to issue the request to and the topics requested. Client applications can use the PubSub+ ..."},"1036":{y:0,u:"../API/API-Developer-Guide/cache/Cache-C-API.htm",l:-1,t:"Using PubSub+ Cache With the C API",i:0.000325896469641359,a:"When a session has been established with a Solace PubSub+ event broker, a client application can create a cache session and then make requests for cached messages (that is, cache requests). The basic steps to make a cache request in a session are: Create a cache session. Refer to  Creating Cache ..."},"1037":{y:0,u:"../API/API-Developer-Guide/cache/Cache-JCSMP-API.htm",l:-1,t:"\n  Using  PubSub+ Cache  With the JCSMP API",i:0.000325896469641359,a:"\n  Using  PubSub+ Cache  With the JCSMP API When a session has been established with a PubSub+ event broker, a client application using the PubSub+ Message API for JCSMP can create a cache session and then make requests for cached messages (that is, cache requests). The basic steps to make a cache ..."},"1038":{y:0,u:"../API/API-Developer-Guide/cache/Cache-Java-RTO-API.htm",l:-1,t:"Using PubSub+ Cache With the Java RTO API",i:0.000296582762034984,a:"When a session has been established with a Solace PubSub+ event broker, a client application using the Solace messaging application programming interface (API) for Java RTO can create a cache session and then make requests for cached messages (that is, cache requests). The basic steps to make a ..."},"1039":{y:0,u:"../API/API-Developer-Guide/cache/Cache-NET-API.htm",l:-1,t:"Using PubSub+ Cache With the .NET API",i:0.00155665584462896,a:"This section describes how to develop applications using the messaging application programming interface (API) for .Net, also known as SolClient for .NET, to perform cache requests over an event broker network. The basic steps to make a cache request in a session are: Create a cache session. Refer ..."},"1040":{y:0,u:"../API/API-Developer-Guide/cache/Cache-JavaScript-API.htm",l:-1,t:"Using PubSub+ Cache With the JavaScript API",i:0.000325896469641359,a:"Client applications can use the Solace Web messaging application programming interface (API) for JavaScript, also known a SolclientJS, to perform cache requests over an event broker network. The basic steps for a connected client to send and receive cache requests in a session are: Create a cache ..."},"1041":{y:0,u:"../API/Developer-Tutorials.htm",l:-1,t:"Developer Tutorials",i:0.000355154375529132,a:" Find code samples, open source projects and tools that should help you make the most of Solace PubSub+."},"1042":{y:0,u:"../API/Samples-VMWareTanzu.htm",l:-1,t:" PubSub+ for VMware Tanzu Overview, Sample, and Tutorial",i:0.000186324170149524,a:" Solace PubSub+ messaging for Pivotal Cloud Foundry provides high-performance, robust, enterprise-grade messaging technology over a wide variety of open protocols."},"1043":{y:0,u:"../API/SDKPerf/SDKPerf.htm",l:-1,t:"SDKPerf",i:0.000519407209773096,a:"SDKPerf is a tool for  validating performance, checking configuration, and exploring features associated with your Solace PubSub+ event broker. SDKPerf is a non-production tool and not officially supported under our Customer Support policy.  You may find SDKPerf useful for developmental and testing ..."},"1044":{y:0,u:"../API/SDKPerf/Command-Line-Options.htm",l:-1,t:"SDKPerf Command Line Options",i:0.000265512329862361,a:"Command Line Options for SDKPerf For a complete list of command line options, enter   –hm (help more) at the command prompt when you start SDKPerf. Common Options The following are the more commonly used command line options: JMS Options JMS users will want to consider the following extra CLI ..."},"1045":{y:0,u:"../API/SDKPerf/Example-Commands.htm",l:-1,t:"Example Commands for SDKPerf",i:0.000186324170149524,a:"The following are example SDKPerf command lines with brief descriptions of the test performed. The goal of this section is to make it easier to determine how to build your own SDKPerf command lines through examples. All of the examples assume the following: You want to connect to the Message VPN ..."},"1046":{y:0,u:"../API/JMSToolBox.htm",l:-1,t:"JMSToolBox",i:0.000190481160215274,a:"You can use JMSToolBox to perform a variety of tasks with PubSub+ event brokers via the JMS API.\n\nSome useful features of JMSToolBox are: \n\nautomatically discovering queues and topics\n browsing and viewing  the contents of messages\n generating messages using a templating scheme\n scripting the ..."},"1047":{y:0,u:"../API/Protocol-Metadata-Payload-Encoding.htm",l:-1,t:"Protocol Metadata and Payload Encoding Interactions",i:0.000653132666944806,a:"Solace PubSub+ supports a wide range of   Open Protocols  such as AMQP, JMS and MQTT. The PubSub+ event broker translates all messages from a protocol-specific message to SMF messages when it receives them. The event broker then translates the messages back from SMF messages to a protocol-specific ..."},"1048":{y:0,u:"../API/API-Developer-Guide/Feature-Support-PubSub-Messaging-APIs.htm",l:-1,t:"Feature Support in PubSub+ Messaging APIs",i:0.00221080281443854,a:"All the PubSub+ Messaging APIs support common functionality that is essential for messaging. These APIs evolve over time to meet use-case requirements for client applications, therefore there are slight differences in feature support. The PubSub+ Messaging API for iOS is a mobile API. For the list ..."},"1049":{y:0,u:"../API/Messaging-APIs/Solace-APIs-Overview.htm",l:-1,t:"PubSub+ Messaging APIs",i:0.0028585644773833,a:"Solace Messaging APIs"},"1050":{y:0,u:"../API/Messaging-APIs/C-API/c-api-home.htm",l:-1,t:"C API",i:0.000595386337447956,a:"Solace C API (called CCSMP)"},"1051":{y:0,u:"../API/IPC/IPC-Guide.htm",l:-1,t:"\n            IPC Guide",i:0.000186324170149524,a:"This section provides an introduction to the Inter-Process Communications (IPC) capabilities of the Solace messaging APIs for C (SolClient) and Java RTO (solclientj). IPC allows applications to communicate directly with each other and to communicate with Solace PubSub+. IPC functionality is ..."},"1052":{y:0,u:"../API/IPC/Client-App-Sessions.htm",l:-1,t:"\n            Client Application Sessions",i:0.000344700489575198,a:"Communications between applications on a single host can occur through shared memory or a shared TCP channel. Communicating through shared memory offers lower overhead and lower latency than communicating through a TCP channel. It is also possible for applications on the same host to use both shared ..."},"1053":{y:0,u:"../API/IPC/IPC-Routing-Behavior.htm",l:-1,t:"IPC Routing Behavior",i:0.000186324170149524,a:"The routing function that occurs within a multi-point session is only used to route an outgoing message from the application to peer applications, based on the subscriptions of the peer applications. A multi-point session does not route between peer applications. For example, in the figure  ..."},"1054":{y:0,u:"../API/IPC/Limitations.htm",l:-1,t:"Limitations",i:0.000186324170149524,a:"IPC has the following limitations: Only Direct messaging is supported; Guaranteed messaging is not supported over IPC connections. Applications communicating over shared memory must have the same memory architecture—that is, 32-bit applications can only communicate over shared memory with other ..."},"1055":{y:0,u:"../API/IPC/Context-Threading-Models.htm",l:-1,t:"Context Threading Models",i:0.000186324170149524,a:"The threading model that you use for IPC depends on whether TCP, shared memory, or both transport types are used within the context. Threading Model for TCP Transport When an IPC session uses TCP communications, the normal context thread is utilized for the message receive processing function and ..."},"1056":{y:0,u:"../API/IPC/Configuring-IPC-Communications.htm",l:-1,t:"Configuring Inter-Process Communications",i:0.000291599939960031,a:"This section discusses Inter-Process Communications configuration information that should be considered when using the C and Java RTO messaging APIs. Context Properties that Affect IPC The following table describes important threading model‑related context properties that affect IPC operations. ..."},"1057":{y:0,u:"../API/IPC/SolGateway.htm",l:-1,t:"SolGateway",i:0.00124191179780723,a:"SolGateway is an application that must be used when IPC applications also want to communicate with other applications through a Solace PubSub+ event broker.  Though it is compatible with both the C and Java RTO APIs, SolGateway is only included in the standard package for the C API. The SolGateway ..."},"1058":{y:0,u:"../API/IPC/Using-IPC-with-the-SDKPerf-Tool.htm",l:-1,t:"Using IPC with the SDKPerf Tool\n",i:0.000186324170149524,a:"Using IPC with the SDKPerf Tool\n This section provides an example of using IPC through the Solace C messaging API-based SDKPerf test tool (sdkperf_c), which is a performance and functional test tool based on the Solace C API. This section assumes that the reader is already familiar with the use of ..."},"1059":{y:0,u:"../API/Messaging-APIs/dotNet-API/net-api-home.htm",l:-1,t:"C# / .NET API",i:0.000544475921294628,a:"Solace C# API, Solace .NET API, CSCSMP"},"1060":{y:0,u:"../API/Messaging-APIs/Go-API/go-home.htm",l:-1,t:"Go API",i:0.000468445624071312,a:"The Solace PubSub+ Messaging API for Go (version 1.6) can be used in cloud-based and enterprise-scale server applications. You can use the PubSub+ Go API with any version of Go that is in support (see  Google, Supported Go Versions ). The Go, Python, Node.js, and JavaScript Messaging APIs share the ..."},"1061":{y:0,u:"../API/API-Developer-Guide-Go/Go-API-Dev-Guide.htm",l:-1,t:"Go API Developer\u0027s Guide",i:0.000265960906978562,a:"The  PubSub+ Messaging API for Go (version 1.6) uses modern development patterns and usability in the form of a native Solace API. The PubSub+ Go API allows your applications to take full advantage of the Solace event broker\u0027s feature set.  The PubSub+ Messaging API for Go utilizes the  builder ..."},"1062":{y:0,u:"../API/API-Developer-Guide-Go/Go-API-Builder-Pattern.htm",l:-1,t:"Builder Pattern Usage in the Go API",i:0.000214582738420774,a:"The PubSub+ Go API uses the builder design pattern to create instances of messages, messaging services, publishers and receivers. Here\u0027s an example usage of the Builder pattern to create  a PubSub+ message:  \n/* Builder for creation of similarly configured messages */\nmessageBuilder := ..."},"1063":{y:0,u:"../API/API-Developer-Guide-Go/Go-API-supported-Environments.htm",l:-1,t:"Supported Environments",i:0.000307597823352188,a:"The PubSub+ Messaging API for Go is compatible and supported with any version of Go that is in active support and also has security update support. For information about supported versions of Go, see  https://go.dev/doc/devel/release .  The PubSub+ Go API is compatible with the following platforms: ..."},"1064":{y:0,u:"../API/API-Developer-Guide-Go/api-versioning.htm",l:-1,t:"Semantic Versioning",i:0.000186324170149524,a:"The PubSub+ Messaging API for Go uses semantic-versioning system that uses a numbering pattern of MAJOR.MINOR.PATCH. With this system, increments to each of these numbers has a specific meaning: MAJOR Incompatible API changes were made MINOR Backwards-compatible functionality was added PATCH ..."},"1065":{y:0,u:"../API/API-Developer-Guide-Go/Go-API-Messaging-Service.htm",l:-1,t:"Messaging Service",i:0.000339746389108055,a:"The PubSub+ Messaging API for Go provides the MessagingService interface, which makes it easy to connect to an event broker. The MessagingService interface handles all the functionality for interacting with a PubSub+ event broker. To create a MessagingService instance, you must first configure a ..."},"1066":{y:0,u:"../API/API-Developer-Guide-Go/Publishing-Messages.htm",l:-1,t:"Publishing Messages",i:0.000186324170149524,a:"The PubSub+ Messaging API for Go allows client applications to publish messages to an SMF (Solace Message Format) topic via the event broker. The messages are then consumed by subscribers (or receivers) subscribed to that topic.  You can publish messages to the event broker in the following ways: ..."},"1067":{y:0,u:"../API/API-Developer-Guide-Go/Go-DM-Publish.htm",l:-1,t:"Publishing Direct Messages Using the Go API",i:0.000603025794347826,a:"Direct messages are useful when high-throughput and low-latency is required. We recommend that you publish events using direct messages if some message loss can be tolerated without negatively impacting client applications. Message loss can occur  due to external factors, such as network congestion ..."},"1068":{y:0,u:"../API/API-Developer-Guide-Go/Go-PM-Publish.htm",l:-1,t:"Publishing Persistent Messages Using the Go API",i:0.00048817361385437,a:"When your applications require confirmation handling and exactly once delivery, we recommend that you use persistent messages instead of  direct messages. To publish persistent messages in the PubSub+ Go API,  you first set up a message queue on the PubSub+ event broker.   For information about ..."},"1069":{y:0,u:"../API/API-Developer-Guide-Go/Receiving-Messages.htm",l:-1,t:"Receiving Messages",i:0.000186324170149524,a:"The PubSub+ Messaging API for Go allows clients to  consume messages published to any topics they are subscribed to. Receivers can consume messages from the event broker in the following ways: Consuming Direct Messages Using the Go API  Direct messaging provides a reliable, but not guaranteed ..."},"1070":{y:0,u:"../API/API-Developer-Guide-Go/Go-DM-Subscribe.htm",l:-1,t:"Consuming Direct Messages Using the Go API ",i:0.000510908388549513,a:"  Direct messaging is useful in scenarios where high-throughput and low-latency is required.  It is possible with the use of direct messages that some  message loss may occur due to external factors, such as network congestion or occasional client disconnections. Direct messages are suitable for ..."},"1071":{y:0,u:"../API/API-Developer-Guide-Go/Go-PM-Subscribe.htm",l:-1,t:"Consuming Persistent Messages Using the Go API ",i:0.000373043005444495,a:" Subscribing applications that cannot tolerate message loss can use persistent messaging (referred to as  guaranteed messages in other parts of this documentation) instead of direct messaging. When persistent messaging is used, messages are stored on a queue on the event broker. Messages are not ..."},"1072":{y:0,u:"../API/API-Developer-Guide-Go/Go-API-Create-Queues.htm",l:-1,t:"Creating Queues with the PubSub+ Go API",i:0.000337873447200198,a:"It is possible to provision queues on the Solace event broker using the Go API and a PersistentMessageReceiverBuilder. These queues can be durable or non-durable (see our blog post  Understanding Solace Endpoints: Durable vs. Non-Durable ), and are not provisioned on the event broker until you call ..."},"1073":{y:0,u:"../API/API-Developer-Guide-Go/Go-API-Distributed-Tracing.htm",l:-1,t:"Context Propagation for Distributed Tracing in the Go API",i:0.000385660591709658,a:"Distributed tracing allows your enterprise applications to trace the flow of messages as they travel from your publisher, through the event mesh and to the receiving application.  For a detailed overview see  Distributed Tracing  .  For  information about version requirements, see  Distributed ..."},"1074":{y:0,u:"../API/API-Developer-Guide-Go/Go-API-Request-Reply.htm",l:-1,t:"Request-Reply Messaging in the Go API",i:0.000311568399211313,a:"Request-reply messaging is a method of data transmission where applications simulate separate point-to-point channels: one for requests, and another for replies. In request-reply messaging, each request sent from a message requestor requires a reply from a message replier. When a message replier ..."},"1075":{y:0,u:"../API/Messaging-APIs/iOS-API/iOS-api-home.htm",l:-1,t:"iOS API",i:0.000461086056982065,a:"The Solace PubSub+ Messaging API for iOS allows applications to send and receive direct messages with a Solace PubSub+ event broker. Message Exchange Patterns The Solace PubSub+ Messaging API for iOS supports all common message exchange patterns. Publish / Subscribe Point-to-Point Request / Reply ..."},"1076":{y:0,u:"../API/Messaging-APIs/Java-API/java-api-home.htm",l:-1,t:"Java API",i:0.000490017483227178,a:"The Solace PubSub+ Messaging API for Java (version 1.6) utilizes modern interfaces, patterns, and usability in a native Java environment. This Java API is suited for developers who want ease-of-use, require a powerful enterprise API, and want to use the next generation of Java APIs from Solace. Like ..."},"1077":{y:0,u:"../API/API-Developer-Guide-Java/Java-API-Dev-Guide.htm",l:-1,t:"Java API Developer\u0027s Guide",i:0.000269628177068695,a:"The  PubSub+ Messaging API for Java (version 1.6) uses modern interfaces, patterns, and usability in a native Java environment. The PubSub+ Java API offers many of the same features as the PubSub+ Messaging API for JCSMP, but requires minimal setup to provide a streamlined developer experience to ..."},"1078":{y:0,u:"../API/API-Developer-Guide-Java/Java-API-Builder-Pattern.htm",l:-1,t:"Builder Pattern Usage in the Java API",i:0.000211789256911642,a:"The PubSub+ Java API uses the builder design pattern to create instances of messages, messaging services, publishers and receivers. Here\u0027s an example usage of the builder pattern to create a PubSub+ message:  \n/* Builder for creation of similarly configured messages */\nfinal OutboundMessageBuilder ..."},"1079":{y:0,u:"../API/API-Developer-Guide-Java/Java-API-supported-environments.htm",l:-1,t:"Supported Environments for the PubSub+ Java API",i:0.000304804341843056,a:"The PubSub+ Messaging API for Java is compatible and supported with any version of the Oracle JDK or OpenJDK that is in active support and also has security update support. For information about supported versions, see the  Oracle Java SE Support Roadmap . The PubSub+ Java API has not been tested ..."},"1080":{y:0,u:"../API/API-Developer-Guide-Java/Java-API-Logging.htm",l:-1,t:"Configuring Logging in the PubSub+ Java API",i:0.000292770345828453,a:"The PubSub+ Java API uses Jakarta Commons Logging (JCL), also known as Apache Commons Logging, to support different logging frameworks. PubSub+ Java API applications can choose either log4j2 or java.util.logging as their logging framework. Supported Log Levels This section shows the different levels ..."},"1081":{y:0,u:"../API/API-Developer-Guide-Java/Java-build-projects.htm",l:-1,t:"Building Java Projects with Maven",i:0.000186324170149524,a:"Apache Maven is a software management tool that can be used to build, install, and distribute Java-based projects. You can retrieve the PubSub+ Messaging API for Java  with either Maven (pom.xml) or Gradle (build.gradle). For the Java API,  you can: obtain the Solace Java API artifacts from  Maven ..."},"1082":{y:0,u:"../API/API-Developer-Guide-Java/api-versioning.htm",l:-1,t:"Semantic Versioning",i:0.000186324170149524,a:"The PubSub+ Messaging API for Java uses semantic-versioning system that uses a numbering pattern of MAJOR.MINOR.PATCH. With this system, increments to each of these numbers has a specific meaning: MAJOR Incompatible API changes were made MINOR Backwards-compatible functionality was added PATCH ..."},"1083":{y:0,u:"../API/API-Developer-Guide-Java/Java-API-samples.htm",l:-1,t:"Using the  Java API Examples",i:0.000211789256911642,a:"You can obtain   code examples for the PubSub+ Messaging API for Java from the  Solace Developer Hub . From the Solace Developer Hub, you can access examples in Git. The Git project contains the following directories: lib—Java libraries src—contains the PubSub+ Java API sample files, including ..."},"1084":{y:0,u:"../API/API-Developer-Guide-Java/Java-Messaging-Service.htm",l:-1,t:"Messaging Service",i:0.000318983944133546,a:"The PubSub+ Messaging API for Java provides the MessagingService interface, which allows you to connect to an event broker. The MessagingService interface handles all the functionality for interacting with a PubSub+ event broker. To create a MessagingService object, you must first configure a ..."},});